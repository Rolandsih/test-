
import json
import os
import asyncio
import schedule
import time
from datetime import datetime, timedelta
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
import threading

TOKEN = "7997467039:AAF86L8qutp9OzG8K5Hfwh1LG4cePd6BPas"
PROMO_CODE = "SANA33"
CONTACT_LINK = "https://t.me/ZACKCASH22"
DATA_FILE = "users.json"
MESSAGES_FILE = "saved_messages.json"
ADMIN_CHAT_ID = None  # Sera dÃ©fini automatiquement lors de la premiÃ¨re connexion admin

# SystÃ¨me de gestion d'Ã©tats pour la diffusion
broadcast_states = {}

# Liens officiels ZACK PCS
INFO_LINK = "https://bot9082.github.io/Info-/"
TIPS_LINK = "https://bot9082.github.io/ZACK-CASH/"
PLATFORM_LINK = "https://1wlucb.life/casino/list/4?p=169j"

# Messages rotatifs personnalisÃ©s ZACK PCS
DAILY_MESSAGES = [
    """Hey {name} !  

ğŸ“Œ ZACK PCS - StratÃ©gies Casino Officielles ğŸ¯

ğŸ° Nouvelle astuce Aviator dÃ©tectÃ©e aujourd'hui !
â° Heures favorables : 14h-16h et 20h-22h
ğŸ”¥ Faille sur roulette europÃ©enne confirmÃ©e !
ğŸ’ Machines Ã  sous : patterns identifiÃ©s sur Book of Ra

ğŸ“š Infos complÃ¨tes : {info_link}
ğŸ“„ Astuces du jour : {tips_link}
ğŸ² Plateforme recommandÃ©e 1win : {platform_link}

ğŸ”‘ Code promo : **{promo}** pour activer tous les avantages !
ğŸ’¬ Support ZACK : {contact}""",

    """Salut {name} !  

ğŸ¯ ZACK PCS - Mise Ã  jour stratÃ©gies ğŸš€

ğŸ’° Gains observÃ©s : +850â‚¬ en 3h avec nos mÃ©thodes !
âš¡ Nouveau schÃ©ma dÃ©tectÃ© sur Crazy Time !
ğŸ² Roulette : mise sur secteurs chauds = 73% rÃ©ussite
ğŸ° Aviator : coefficient optimal entre x1.4 et x2.1

ğŸ“– Guide complet : {info_link}
ğŸ”¥ DerniÃ¨res astuces : {tips_link}
ğŸ† Inscription 1win : {platform_link}

âœ… Code **{promo}** = retraits rapides + bonus exclusifs
ğŸ“± Contact direct : {contact}""",

    """Hey {name} !  

ğŸ”¥ ZACK PCS - Alertes Failles Casino âš ï¸

ğŸ° URGENT : Faille Sweet Bonanza active jusqu'Ã  minuit !
ğŸ’ Machines progressives : jackpots prÃ¨s d'exploser !
ğŸ² Roulette live : dealer favorable identifiÃ© salle 3
â­ Aviator : algorithme prÃ©visible entre 18h-20h

ğŸ“‹ ProcÃ©dures dÃ©taillÃ©es : {info_link}
ğŸ’¯ StratÃ©gies actualisÃ©es : {tips_link}
ğŸ¯ Plateforme sÃ©curisÃ©e : {platform_link}

ğŸ”‘ OBLIGATOIRE : Code **{promo}** pour accÃ¨s complet
ğŸ“ Aide personnalisÃ©e : {contact}""",

    """Bonjour {name} !  

ğŸ’¸ ZACK PCS - RÃ©sultats Exceptionnels ğŸ“Š

ğŸš€ Record battu : +1,200â‚¬ en une session !
ğŸ° Aviator : 9 gains consÃ©cutifs avec notre timing
ğŸ”¥ Blackjack live : stratÃ©gie optimisÃ©e = 68% victoires
ğŸ’ Slots volatiles : moments idÃ©aux pour jouer gros

ğŸ“š MÃ©thodes complÃ¨tes : {info_link}
âš¡ Tips actualisÃ©s : {tips_link}
ğŸ… Compte optimisÃ© 1win : {platform_link}

âœ¨ Code **{promo}** = avantages VIP instantanÃ©s
ğŸ’¬ Questions ? Ã‰cris : {contact}""",

    """Coucou {name} !  

â­ ZACK PCS - OpportunitÃ©s LimitÃ©es â³

ğŸ¯ DERNIÃˆRES 6H : Faille mega jackpot disponible !
ğŸ’° Gains moyens constatÃ©s : +650â‚¬/jour avec nos tips
ğŸ² Roulette franÃ§aise : sÃ©rie rouge/noir prÃ©visible
ğŸ° Gates of Olympus : multiplicateurs x500 frÃ©quents

ğŸ“– AccÃ¨s formations : {info_link}
ğŸ”¥ Astuces temps rÃ©el : {tips_link}
ğŸª Interface optimale : {platform_link}

ğŸ”‘ Code magique **{promo}** pour dÃ©bloquer tout
ğŸ“² Support expert : {contact}""",

    """Bonsoir {name} ! ğŸŒ™

ğŸ² ZACK PCS - Session Nocturne SpÃ©ciale 
ğŸ¦‰ Les nuits sont les plus rentables sur 1win !
ğŸ° Aviator : moins de concurrence = plus de gains
ğŸ’° Roulette after midnight : tendances prÃ©visibles
ğŸ”¥ Bonus nocturnes jusqu'Ã  +200% disponibles !

ğŸ“Š Stats prouvÃ©es : +40% gains de 22h Ã  2h
âš¡ Multiplicateurs frÃ©quents dÃ©tectÃ©s
ğŸ¯ Jackpots progressifs : seuils critiques atteints

ğŸ“š Guide nocturne : {info_link}
ğŸ”¥ StratÃ©gies nuit : {tips_link}
ğŸŒ™ Session optimale : {platform_link}

ğŸ”‘ Code nuit **{promo}** = bonus supplÃ©mentaires
ğŸ’¬ Support 24h/7j : {contact}""",

    """Hello {name} ! ğŸ‘‹

ğŸš¨ ZACK PCS - Alerte Gains Exceptionnels 
ğŸ’¥ BREAKING : Nouveau record Ã©tabli +2,400â‚¬ !
ğŸ° Technique secrÃ¨te rÃ©vÃ©lÃ©e aujourd'hui uniquement
ğŸ”¥ 5 utilisateurs ont dÃ©passÃ© 1000â‚¬ cette semaine
âš¡ Pattern exceptionnel dÃ©couvert sur Plinko

ğŸ¯ RÃ©sultats cette semaine :
â€¢ Aviator : 89% de rÃ©ussite
â€¢ Roulette : 76% sur nos secteurs
â€¢ Slots : x1000+ atteints 3 fois

ğŸ“– MÃ©thode complÃ¨te : {info_link}
ğŸ”¥ Techniques avancÃ©es : {tips_link}
ğŸ† Plateforme premium : {platform_link}

ğŸ”‘ Code VIP **{promo}** = accÃ¨s prioritaire
ğŸ“ Coaching perso : {contact}""",

    """Yo {name} ! ğŸ”¥

âš¡ ZACK PCS - Flash Info Casino 
ğŸ¯ URGENT : Maintenance 1win prÃ©vue demain 14h !
ğŸ’° Profitez maintenant avant l'interruption
ğŸ° Aviator : coefficient x25 observÃ© 3 fois aujourd'hui  
ğŸ”¥ Sweet Bonanza : free spins en masse dÃ©tectÃ©s

â° CrÃ©neaux optimaux restants :
â€¢ 16h-18h : Roulette europÃ©enne  
â€¢ 19h-21h : Machines volatiles
â€¢ 22h-00h : Aviator premium

ğŸ“š StratÃ©gies flash : {info_link}
âš¡ Tips minute : {tips_link}
ğŸ² AccÃ¨s direct : {platform_link}

ğŸ”‘ Code flash **{promo}** = bonus immÃ©diat
ğŸ’¬ Urgence ? Contacte : {contact}"""
]


def load_users():
    """Charge les utilisateurs depuis le fichier JSON"""
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_users(users_data):
    """Sauvegarde les utilisateurs dans le fichier JSON"""
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump(users_data, f, ensure_ascii=False, indent=2)


def load_saved_messages():
    """Charge les messages sauvegardÃ©s depuis le fichier JSON"""
    if os.path.exists(MESSAGES_FILE):
        try:
            with open(MESSAGES_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return []
    return []


def save_messages(messages_data):
    """Sauvegarde les messages dans le fichier JSON"""
    with open(MESSAGES_FILE, 'w', encoding='utf-8') as f:
        json.dump(messages_data, f, ensure_ascii=False, indent=2)


def get_user_name(update: Update):
    """RÃ©cupÃ¨re le nom/pseudo de l'utilisateur"""
    user = update.effective_user
    if user.first_name:
        return user.first_name
    elif user.username:
        return user.username
    else:
        return "ami"


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /start - Accueille et enregistre l'utilisateur"""
    user_id = str(update.effective_user.id)
    user_name = get_user_name(update)

    # Charger les donnÃ©es existantes
    users_data = load_users()

    # Ajouter/mettre Ã  jour l'utilisateur
    users_data[user_id] = {
        "name": user_name,
        "username": update.effective_user.username,
        "registered_date": datetime.now().isoformat(),
        "last_message": None
    }

    # Sauvegarder
    save_users(users_data)

    welcome_message = f"""ğŸ¯ BIENVENUE {user_name.upper()} DANS L'Ã‰LITE ZACK PCS !

ğŸ”¥ Tu viens de rejoindre le cercle privÃ© des stratÃ©gies casino les plus rentables :

ğŸ’° GAINS QUOTIDIENS OBSERVÃ‰S :
â€¢ Aviator : +450â‚¬ Ã  +1,200â‚¬ par session
â€¢ Roulette Live : 73% de rÃ©ussite sur nos secteurs
â€¢ Machines Ã  sous : Multiplicateurs x500+ frÃ©quents
â€¢ Blackjack VIP : StratÃ©gies optimisÃ©es = 68% victoires

âš¡ ACCÃˆS IMMÃ‰DIAT Ã€ :
ğŸ² Failles dÃ©tectÃ©es en temps rÃ©el
ğŸ“Š Heures favorables calculÃ©es par IA
ğŸ¯ Patterns exclusifs sur 1win Casino
ğŸ” Alertes multiplicateurs exceptionnels

ğŸ“š Ressources VIP : {INFO_LINK}
ğŸ”¥ Astuces temps rÃ©el : {TIPS_LINK}
ğŸ† Plateforme premium : {PLATFORM_LINK}

ğŸ”‘ Code magique : {PROMO_CODE} (activation instantanÃ©e)
ğŸ’¬ Support expert 24/7 : {CONTACT_LINK}

ğŸš¨ ATTENTION : Nos mÃ©thodes ont permis +15,000â‚¬ de gains cette semaine !

âœ… Messages personnalisÃ©s activÃ©s - PrÃ©pare-toi Ã  exploser tes gains !"""

    await update.message.reply_text(welcome_message)


async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /stats - Affiche les statistiques"""
    users_data = load_users()
    saved_messages = load_saved_messages()
    total_users = len(users_data)
    total_saved_messages = len(saved_messages)

    stats_message = f"""ğŸ“Š **Statistiques du bot :**

ğŸ‘¥ Total d'utilisateurs inscrits : **{total_users}**
ğŸ“§ Messages sauvegardÃ©s : **{total_saved_messages}**
ğŸ”‘ Code promo actif : **{PROMO_CODE}**
ğŸ“… DerniÃ¨re mise Ã  jour : {datetime.now().strftime('%d/%m/%Y %H:%M')}"""

    await update.message.reply_text(stats_message)


async def broadcast_daily_messages():
    """Envoie les messages quotidiens Ã  tous les utilisateurs"""
    global ADMIN_CHAT_ID

    users_data = load_users()

    # Choisir un message du jour (rotation basÃ©e sur le jour de l'annÃ©e)
    day_of_year = datetime.now().timetuple().tm_yday
    message_template = DAILY_MESSAGES[day_of_year % len(DAILY_MESSAGES)]

    # CrÃ©er l'application pour envoyer des messages
    app = ApplicationBuilder().token(TOKEN).build()

    sent_count = 0

    # Si pas d'utilisateurs ET que l'admin est connectÃ©, envoyer un message test
    if not users_data and ADMIN_CHAT_ID is not None:
        print("Aucun utilisateur enregistrÃ©, envoi d'un message test Ã  l'admin")
        try:
            test_message = f"""ğŸ§ª MESSAGE TEST ZACK PCS

ğŸ‘‹ Salut Admin ! Voici un exemple de message quotidien :

{message_template.format(
                name="Admin", 
                contact=CONTACT_LINK, 
                promo=PROMO_CODE,
                info_link=INFO_LINK,
                tips_link=TIPS_LINK,
                platform_link=PLATFORM_LINK
            )}

âœ… Le systÃ¨me de messages automatiques fonctionne parfaitement !
ğŸ“Š Utilisateurs inscrits : 0 pour le moment"""

            await app.bot.send_message(chat_id=int(ADMIN_CHAT_ID), text=test_message)
            print("âœ… Message test envoyÃ© Ã  l'admin")
            return
        except Exception as e:
            print(f"âŒ Erreur envoi message test Ã  l'admin: {e}")
            return

    # Envoyer aux utilisateurs enregistrÃ©s
    for user_id, user_data in users_data.items():
        try:
            # Personnaliser le message
            personalized_message = message_template.format(
                name=user_data["name"], 
                contact=CONTACT_LINK, 
                promo=PROMO_CODE,
                info_link=INFO_LINK,
                tips_link=TIPS_LINK,
                platform_link=PLATFORM_LINK
            )

            # Envoyer le message
            await app.bot.send_message(chat_id=int(user_id), text=personalized_message)

            # Mettre Ã  jour la date du dernier message
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            sent_count += 1

            # Petite pause pour Ã©viter le spam
            await asyncio.sleep(1)

        except Exception as e:
            print(f"Erreur envoi message Ã  {user_id}: {e}")

    # Sauvegarder les mises Ã  jour
    save_users(users_data)
    print(f"Messages quotidiens envoyÃ©s Ã  {sent_count} utilisateurs")


async def send_test_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /test - Envoie un message test personnalisÃ©"""
    user_name = get_user_name(update)
    test_message = DAILY_MESSAGES[0].format(
        name=user_name,
        contact=CONTACT_LINK,
        promo=PROMO_CODE,
        info_link=INFO_LINK,
        tips_link=TIPS_LINK,
        platform_link=PLATFORM_LINK
    )
    await update.message.reply_text(f"ğŸ“§ **Message test :**\n\n{test_message}")


# SystÃ¨me de menus spÃ©ciaux
secret_menus = {}

async def admin_panel_access(message_text, update: Update):
    """Fonction pour gÃ©rer l'accÃ¨s admin directement dans les messages"""
    global ADMIN_CHAT_ID

    # NOUVEAU : Code secret LMM8 pour accÃ¨s au menu de gestion
    if message_text == "LMM8":
        user_id = update.effective_user.id
        user_name = get_user_name(update)
        
        # Activer le menu secret pour cet utilisateur
        secret_menus[user_id] = {
            "active": True,
            "step": "main_menu"
        }
        
        menu_message = f"""ğŸ” MENU SECRET ACTIVÃ‰
ğŸ‘‹ Salut {user_name} !

ğŸ¯ Options disponibles :

1ï¸âƒ£ AJOUTER MESSAGE - CrÃ©er un nouveau message quotidien
2ï¸âƒ£ VOIR MESSAGES - Liste complÃ¨te des messages sauvegardÃ©s  
3ï¸âƒ£ SUPPRIMER MESSAGE - Effacer un message spÃ©cifique
4ï¸âƒ£ SUPPRIMER TOUS - Vider tous les messages personnalisÃ©s
5ï¸âƒ£ DIFFUSER MAINTENANT - Envoyer un message immÃ©diatement
6ï¸âƒ£ STATISTIQUES - Voir les stats du bot
7ï¸âƒ£ QUITTER - Fermer ce menu

ğŸ“ Tapez le numÃ©ro de votre choix (1 Ã  7)
ğŸ–¼ï¸ Support complet : Images, vidÃ©os et documents acceptÃ©s !"""

        await update.message.reply_text(menu_message)
        return True

    # Ancien systÃ¨me admin (gardÃ© en backup)
    if message_text == "SIHO ISAAC ROLAND 840106":
        ADMIN_CHAT_ID = update.effective_user.id
        print(f"âœ… ADMIN_CHAT_ID dÃ©fini automatiquement : {ADMIN_CHAT_ID}")

        users_data = load_users()
        saved_messages = load_saved_messages()
        current_time = datetime.now()

        admin_header = f"""ğŸ‘‘ **PANNEAU ADMINISTRATION - ZACK PCS**
ğŸ”“ AccÃ¨s autorisÃ© pour : **SIHO ISAAC ROLAND**
â° Connexion : {current_time.strftime('%d/%m/%Y Ã  %H:%M:%S')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

        await update.message.reply_text(admin_header)

        total_users = len(users_data)
        total_saved_messages = len(saved_messages)

        stats_message = f"""ğŸ“Š **STATISTIQUES DU BOT**

ğŸ‘¥ **Utilisateurs totaux :** {total_users}
ğŸ“§ **Messages sauvegardÃ©s :** {total_saved_messages}
ğŸ”‘ **Code promo actif :** {PROMO_CODE}
ğŸ¤– **Status bot :** âœ… OpÃ©rationnel
â° **Messages auto :** 9h00 et 18h00
ğŸ”— **Plateforme liÃ©e :** 1win Casino

ğŸ¯ **Commandes disponibles :**
â€¢ `/broadcast` - Diffuser un message
â€¢ `/stats` - Voir les statistiques
â€¢ `/test` - Tester un message

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

        await update.message.reply_text(stats_message)
        return True

    return False


async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /broadcast - Diffusion de messages pour les administrateurs"""
    global ADMIN_CHAT_ID

    user_id = update.effective_user.id

    # VÃ©rifier si c'est l'administrateur
    if ADMIN_CHAT_ID is None or user_id != ADMIN_CHAT_ID:
        await update.message.reply_text("âŒ AccÃ¨s refusÃ©. Vous devez d'abord vous connecter avec le code admin.")
        return

    # Initialiser l'Ã©tat de diffusion pour cet admin
    broadcast_states[user_id] = {
        "step": "waiting_message",
        "message": None,
        "media_type": None,
        "media_file": None
    }

    await update.message.reply_text("""ğŸ“¢ **MODE DIFFUSION ACTIVÃ‰**

ğŸ‘‘ Admin connectÃ© : **SIHO ISAAC ROLAND**

ğŸ“ **Ã‰tape 1/3 :** Saisissez le message que vous souhaitez diffuser Ã  tous vos utilisateurs.

ğŸ–¼ï¸ **NOUVEAU :** Vous pouvez aussi envoyer des images ou vidÃ©os avec votre message !

âš ï¸ Ce message sera envoyÃ© Ã  tous les utilisateurs inscrits au bot ZACK PCS.

âœï¸ Tapez votre message maintenant ou envoyez une image/vidÃ©o :""")


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /help"""
    global ADMIN_CHAT_ID

    user_id = update.effective_user.id

    if ADMIN_CHAT_ID is not None and user_id == ADMIN_CHAT_ID:
        help_text = f"""ğŸ¤– **Commandes disponibles (ADMIN) :**

/start - S'inscrire et recevoir l'accueil
/test - Voir un exemple de message quotidien
/stats - Voir les statistiques
/broadcast - ğŸ“¢ Diffuser un message Ã  tous les utilisateurs
/help - Cette aide

ğŸ” **Menu secret :** Tapez **LMM8** pour accÃ©der aux fonctions avancÃ©es

ğŸ”‘ **Code promo :** {PROMO_CODE}
ğŸ“± **Support :** {CONTACT_LINK}

âœ… Les messages personnalisÃ©s sont envoyÃ©s automatiquement chaque jour !"""
    else:
        help_text = f"""ğŸ¤– **Commandes disponibles :**

/start - S'inscrire et recevoir l'accueil
/test - Voir un exemple de message quotidien
/stats - Voir les statistiques
/help - Cette aide

ğŸ”‘ **Code promo :** {PROMO_CODE}
ğŸ“± **Support :** {CONTACT_LINK}

âœ… Les messages personnalisÃ©s sont envoyÃ©s automatiquement chaque jour !"""

    await update.message.reply_text(help_text)


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestion des messages non-commandes"""
    message_text = update.message.text if update.message.text else ""
    user_id = update.effective_user.id

    # PRIORITÃ‰ 1 : GÃ©rer le processus de diffusion si actif
    if user_id in broadcast_states:
        await handle_broadcast_process(update, context)
        return

    # PRIORITÃ‰ 2 : GÃ©rer le menu secret si actif
    if user_id in secret_menus:
        await handle_secret_menu(update, context)
        return

    # PRIORITÃ‰ 3 : VÃ©rifier l'accÃ¨s admin direct
    if message_text:
        admin_handled = await admin_panel_access(message_text, update)
        if admin_handled:
            return

    # PRIORITÃ‰ 4 : RÃ©ponses automatiques basiques
    user_name = get_user_name(update)
    if message_text:
        message_text_lower = message_text.lower()

        if PROMO_CODE.lower() in message_text_lower:
            await update.message.reply_text(
                f"ğŸ¯ Parfait {user_name} ! Tu as mentionnÃ© le code {PROMO_CODE}. Tu es dans le bon chemin pour maximiser tes gains ! ğŸ’°"
            )
        elif any(word in message_text_lower for word in ["aide", "help", "problÃ¨me", "question"]):
            await update.message.reply_text(
                f"ğŸ“ {user_name}, je suis lÃ  pour t'aider ! Contacte-moi directement : {CONTACT_LINK}"
            )
        elif any(word in message_text_lower for word in ["merci", "thanks"]):
            await update.message.reply_text(
                f"ğŸ™ De rien {user_name} ! Continue comme Ã§a, les gains vont exploser ! ğŸš€"
            )


async def handle_secret_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re le menu secret LMM8"""
    user_id = update.effective_user.id
    message_text = update.message.text if update.message.text else ""
    
    if user_id not in secret_menus:
        return
    
    # VÃ©rifier si c'est un Ã©tat temporaire aprÃ¨s sortie
    if secret_menus[user_id].get("temp_exit", False):
        # Nettoyer l'Ã©tat temporaire
        del secret_menus[user_id]
        return
    
    # NOUVELLE FONCTIONNALITÃ‰ : Commande universelle pour sortir du menu
    if message_text.upper() in ["SORTIR", "EXIT", "QUITTER", "RETOUR"]:
        # Supprimer le dernier message du bot s'il existe
        if 'last_bot_message_id' in secret_menus[user_id]:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=secret_menus[user_id]['last_bot_message_id']
                )
            except:
                pass
        
        del secret_menus[user_id]
        await update.message.reply_text("""ğŸšª SORTIE DU MENU RÃ‰USSIE

âœ… Vous avez quittÃ© le menu secret avec succÃ¨s.
ğŸ’¡ Tapez **LMM8** Ã  nouveau pour rouvrir le menu.

ğŸ¯ Merci d'avoir utilisÃ© le systÃ¨me de gestion ZACK PCS !""")
        return
        
    menu_state = secret_menus[user_id]
    
    # VÃ©rifier que l'Ã©tat a bien une clÃ© "step"
    if "step" not in menu_state:
        # RÃ©initialiser l'Ã©tat du menu en cas de problÃ¨me
        secret_menus[user_id] = {
            "active": True,
            "step": "main_menu"
        }
        menu_state = secret_menus[user_id]
    
    # Menu principal
    if menu_state["step"] == "main_menu":
        # Supprimer le message prÃ©cÃ©dent du bot s'il existe
        if 'last_bot_message_id' in menu_state:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=menu_state['last_bot_message_id']
                )
            except:
                pass
        
        if message_text == "1":
            # Ajouter un message
            secret_menus[user_id]["step"] = "add_message"
            sent_message = await update.message.reply_text("""âœï¸ AJOUTER UN NOUVEAU MESSAGE

ğŸ“ Tapez le message que vous voulez ajouter Ã  la liste des messages quotidiens.

ğŸ–¼ï¸ NOUVEAU : Vous pouvez aussi envoyer une image ou vidÃ©o avec votre message !

âš¡ Ce message sera ajoutÃ© aux messages rotatifs et envoyÃ© automatiquement aux utilisateurs.

ğŸ’¡ Variables disponibles :
â€¢ {name} - Nom de l'utilisateur
â€¢ {contact} - Lien de contact  
â€¢ {promo} - Code promo
â€¢ {info_link} - Lien d'informations
â€¢ {tips_link} - Lien des astuces
â€¢ {platform_link} - Lien de la plateforme

ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu Ã  tout moment

âœï¸ Tapez votre message maintenant ou envoyez une image/vidÃ©o :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "2":
            # Voir les messages existants
            saved_messages = load_saved_messages()
            total_daily = len(DAILY_MESSAGES)
            total_saved = len(saved_messages)
            
            if not saved_messages:
                messages_list = f"""ğŸ“‹ MESSAGES SAUVEGARDÃ‰S

ğŸ“Š Messages quotidiens par dÃ©faut : {total_daily}
ğŸ’¾ Messages personnalisÃ©s : 0
ğŸ“§ Total : {total_daily}

âŒ Aucun message personnalisÃ© sauvegardÃ©.

ğŸ’¡ Options :
â€¢ Tapez 1 pour ajouter votre premier message
â€¢ Tapez 7 pour revenir au menu principal
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu"""
            else:
                messages_list = f"""ğŸ“‹ LISTE COMPLÃˆTE DES MESSAGES

ğŸ“Š Messages quotidiens par dÃ©faut : {total_daily}
ğŸ’¾ Messages personnalisÃ©s : {total_saved}
ğŸ“§ Total : {total_daily + total_saved}

ğŸ“ VOS MESSAGES PERSONNALISÃ‰S :

"""
                for i, msg in enumerate(saved_messages, 1):
                    preview = msg['content'][:80] + "..." if len(msg['content']) > 80 else msg['content']
                    msg_type = f"[{msg['type'].upper()}] " if msg['type'] != 'text' else ""
                    date_created = msg.get('created_date', '')[:10] if msg.get('created_date') else 'Date inconnue'
                    messages_list += f"{i}. {msg_type}{preview}\n   ğŸ“… CrÃ©Ã© le : {date_created}\n\n"
                
                messages_list += f"""ğŸ’¡ Options :
ğŸ”™ Tapez 7 pour revenir au menu principal
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(messages_list)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "3":
            # Supprimer un message spÃ©cifique
            saved_messages = load_saved_messages()
            if not saved_messages:
                sent_message = await update.message.reply_text("""âŒ AUCUN MESSAGE Ã€ SUPPRIMER

ğŸ“­ Vous n'avez pas encore de messages personnalisÃ©s sauvegardÃ©s.

ğŸ’¡ Options :
1ï¸âƒ£ Ajouter un message d'abord
7ï¸âƒ£ Revenir au menu principal
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu

ğŸ“ Tapez votre choix :""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                secret_menus[user_id]["step"] = "delete_one_message"
                delete_list = """ğŸ—‘ï¸ SUPPRIMER UN MESSAGE SPÃ‰CIFIQUE

ğŸ“ Voici la liste de vos messages personnalisÃ©s :

"""
                for i, msg in enumerate(saved_messages, 1):
                    preview = msg['content'][:100] + "..." if len(msg['content']) > 100 else msg['content']
                    msg_type = f"[{msg['type'].upper()}] " if msg['type'] != 'text' else ""
                    date_created = msg.get('created_date', '')[:10] if msg.get('created_date') else 'Date inconnue'
                    delete_list += f"""â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{i}ï¸âƒ£ {msg_type}MESSAGE #{i}
ğŸ“… CrÃ©Ã© le : {date_created}
ğŸ“ Contenu : {preview}

"""
                
                delete_list += f"""ğŸ”¢ Tapez le numÃ©ro du message Ã  supprimer (1-{len(saved_messages)})
âŒ Tapez 0 pour annuler et revenir au menu
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(delete_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "4":
            # Supprimer TOUS les messages
            saved_messages = load_saved_messages()
            if not saved_messages:
                sent_message = await update.message.reply_text("""âŒ AUCUN MESSAGE Ã€ SUPPRIMER

ğŸ“­ Vous n'avez pas de messages personnalisÃ©s sauvegardÃ©s.

ğŸ’¡ Tapez 1 pour ajouter un message.
ğŸ”™ Tapez 7 pour revenir au menu principal.
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                secret_menus[user_id]["step"] = "delete_all_messages"
                sent_message = await update.message.reply_text(f"""âš ï¸ SUPPRIMER TOUS LES MESSAGES

ğŸ—‘ï¸ Vous Ãªtes sur le point de supprimer TOUS vos messages personnalisÃ©s !

ğŸ“Š Messages qui seront supprimÃ©s : {len(saved_messages)}
âš ï¸ Cette action est IRRÃ‰VERSIBLE !

â“ ÃŠtes-vous sÃ»r de vouloir continuer ?

âœ… Tapez OUI pour confirmer la suppression
âŒ Tapez NON pour annuler
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
        elif message_text == "5":
            # Diffuser maintenant
            secret_menus[user_id]["step"] = "broadcast_now"
            sent_message = await update.message.reply_text("""ğŸ“¢ DIFFUSION IMMÃ‰DIATE

ğŸ“ Tapez le message que vous voulez envoyer maintenant Ã  tous les utilisateurs.

ğŸ–¼ï¸ NOUVEAU : Vous pouvez aussi envoyer une image ou vidÃ©o !

âš ï¸ Ce message sera envoyÃ© immÃ©diatement, pas ajoutÃ© aux messages quotidiens.

ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu Ã  tout moment

âœï¸ Tapez votre message ou envoyez un mÃ©dia :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "6":
            # Statistiques
            users_data = load_users()
            saved_messages = load_saved_messages()
            stats_msg = f"""ğŸ“Š STATISTIQUES COMPLÃˆTES

ğŸ‘¥ Utilisateurs inscrits : {len(users_data)}
ğŸ“§ Messages quotidiens par dÃ©faut : {len(DAILY_MESSAGES)}
ğŸ’¾ Messages personnalisÃ©s : {len(saved_messages)}
ğŸ”‘ Code promo actif : {PROMO_CODE}
â° Envois programmÃ©s : 9h00 et 18h00
ğŸ“… DerniÃ¨re activitÃ© : {datetime.now().strftime('%d/%m/%Y %H:%M')}

ğŸ”™ Tapez 7 pour revenir au menu principal
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu"""
            sent_message = await update.message.reply_text(stats_msg)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "7":
            # Quitter
            # Supprimer le message prÃ©cÃ©dent du bot
            if 'last_bot_message_id' in menu_state:
                try:
                    await context.bot.delete_message(
                        chat_id=user_id, 
                        message_id=menu_state['last_bot_message_id']
                    )
                except:
                    pass
            
            del secret_menus[user_id]
            await update.message.reply_text("""âœ… MENU FERMÃ‰

ğŸ” Session terminÃ©e avec succÃ¨s.
ğŸ’¡ Tapez **LMM8** Ã  nouveau pour rouvrir le menu secret.

ğŸ¯ Merci d'avoir utilisÃ© le systÃ¨me de gestion ZACK PCS !""")
            
        else:
            sent_message = await update.message.reply_text("""âŒ Option invalide

ğŸ¯ Choisissez un numÃ©ro entre 1 et 7 :

1ï¸âƒ£ Ajouter message
2ï¸âƒ£ Voir messages  
3ï¸âƒ£ Supprimer message
4ï¸âƒ£ Supprimer tous
5ï¸âƒ£ Diffuser maintenant
6ï¸âƒ£ Statistiques
7ï¸âƒ£ Quitter
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    # Ajouter un nouveau message
    elif menu_state["step"] == "add_message":
        # Supprimer le message prÃ©cÃ©dent du bot
        if 'last_bot_message_id' in menu_state:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=menu_state['last_bot_message_id']
                )
            except:
                pass
        
        # DÃ©terminer le type de message
        message_type = "text"
        media_file_id = None
        content = message_text
        
        if update.message.photo:
            message_type = "photo"
            media_file_id = update.message.photo[-1].file_id
            content = update.message.caption or ""
        elif update.message.video:
            message_type = "video"
            media_file_id = update.message.video.file_id
            content = update.message.caption or ""
        elif update.message.document:
            message_type = "document"
            media_file_id = update.message.document.file_id
            content = update.message.caption or ""
        
        # Sauvegarder le message
        saved_messages = load_saved_messages()
        new_message = {
            "id": len(saved_messages) + 1,
            "type": message_type,
            "content": content,
            "media_file_id": media_file_id,
            "created_date": datetime.now().isoformat()
        }
        saved_messages.append(new_message)
        save_messages(saved_messages)
        
        message_type_text = {"photo": "ğŸ–¼ï¸ Image", "video": "ğŸ¬ VidÃ©o", "document": "ğŸ“ Document", "text": "ğŸ“ Texte"}
        
        sent_message = await update.message.reply_text(f"""âœ… MESSAGE AJOUTÃ‰ AVEC SUCCÃˆS !

{message_type_text.get(message_type, "ğŸ“")} Votre message a Ã©tÃ© sauvegardÃ©.
ğŸ“Š Total de messages personnalisÃ©s : {len(saved_messages)}

ğŸ”„ Ce message peut maintenant Ãªtre utilisÃ© pour la diffusion.

ğŸ”™ MENU PRINCIPAL :

1ï¸âƒ£ AJOUTER MESSAGE - CrÃ©er un nouveau message quotidien
2ï¸âƒ£ VOIR MESSAGES - Liste complÃ¨te des messages sauvegardÃ©s  
3ï¸âƒ£ SUPPRIMER MESSAGE - Effacer un message spÃ©cifique
4ï¸âƒ£ SUPPRIMER TOUS - Vider tous les messages personnalisÃ©s
5ï¸âƒ£ DIFFUSER MAINTENANT - Envoyer un message immÃ©diatement
6ï¸âƒ£ STATISTIQUES - Voir les stats du bot
7ï¸âƒ£ QUITTER - Fermer ce menu
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu

ğŸ“ Tapez le numÃ©ro de votre choix (1 Ã  7) :""")
        
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    # Supprimer un message spÃ©cifique  
    elif menu_state["step"] == "delete_one_message":
        # Supprimer le message prÃ©cÃ©dent du bot
        if 'last_bot_message_id' in menu_state:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=menu_state['last_bot_message_id']
                )
            except:
                pass
        
        try:
            choice = int(message_text)
            saved_messages = load_saved_messages()
            
            if choice == 0:
                sent_message = await update.message.reply_text("""âŒ SUPPRESSION ANNULÃ‰E

ğŸ”™ Retour au menu principal :

1ï¸âƒ£ Ajouter message
2ï¸âƒ£ Voir messages  
3ï¸âƒ£ Supprimer message
4ï¸âƒ£ Supprimer tous
5ï¸âƒ£ Diffuser maintenant
6ï¸âƒ£ Statistiques
7ï¸âƒ£ Quitter
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu

ğŸ“ Tapez votre choix :""")
                secret_menus[user_id]["step"] = "main_menu"
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
                
            elif 1 <= choice <= len(saved_messages):
                # Afficher le message qui va Ãªtre supprimÃ© pour confirmation
                deleted_msg = saved_messages[choice - 1]
                preview = deleted_msg['content'][:150] + "..." if len(deleted_msg['content']) > 150 else deleted_msg['content']
                msg_type = f"[{deleted_msg['type'].upper()}] " if deleted_msg['type'] != 'text' else ""
                
                # Supprimer le message
                saved_messages.pop(choice - 1)
                save_messages(saved_messages)
                
                sent_message = await update.message.reply_text(f"""âœ… MESSAGE SUPPRIMÃ‰ AVEC SUCCÃˆS !

ğŸ—‘ï¸ Message supprimÃ© :
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{msg_type}{preview}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š Messages personnalisÃ©s restants : {len(saved_messages)}

ğŸ”™ Retour au menu principal :

1ï¸âƒ£ Ajouter message
2ï¸âƒ£ Voir messages restants
3ï¸âƒ£ Supprimer un autre message
4ï¸âƒ£ Supprimer tous les messages
5ï¸âƒ£ Diffuser maintenant
6ï¸âƒ£ Statistiques
7ï¸âƒ£ Quitter
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu

ğŸ“ Tapez votre choix :""")
                secret_menus[user_id]["step"] = "main_menu"
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
                
            else:
                sent_message = await update.message.reply_text(f"""âŒ NUMÃ‰RO INVALIDE

ğŸ”¢ Veuillez choisir un numÃ©ro entre 1 et {len(saved_messages)}
âŒ Ou tapez 0 pour annuler et revenir au menu
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu

ğŸ“ Votre choix :""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
                
        except ValueError:
            sent_message = await update.message.reply_text("""âŒ FORMAT INVALIDE

ğŸ”¢ Tapez uniquement un numÃ©ro (pas de texte)
ğŸ’¡ Exemple : tapez 1 pour supprimer le message #1
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu

ğŸ“ Votre choix :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    # Supprimer TOUS les messages
    elif menu_state["step"] == "delete_all_messages":
        # Supprimer le message prÃ©cÃ©dent du bot
        if 'last_bot_message_id' in menu_state:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=menu_state['last_bot_message_id']
                )
            except:
                pass
        
        if message_text.upper() == "OUI":
            saved_messages = load_saved_messages()
            total_deleted = len(saved_messages)
            save_messages([])  # Vider la liste
            
            sent_message = await update.message.reply_text(f"""âœ… TOUS LES MESSAGES SUPPRIMÃ‰S !

ğŸ—‘ï¸ {total_deleted} messages personnalisÃ©s ont Ã©tÃ© supprimÃ©s.
ğŸ“Š Messages restants : 0
ğŸ”„ Seuls les messages quotidiens par dÃ©faut restent actifs.

ğŸ”™ Retour au menu principal :

1ï¸âƒ£ Ajouter un nouveau message
2ï¸âƒ£ Voir messages (vide maintenant)
7ï¸âƒ£ Retour menu principal
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["step"] = "main_menu"
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text.upper() == "NON":
            sent_message = await update.message.reply_text("""âŒ SUPPRESSION ANNULÃ‰E

ğŸ›¡ï¸ Tous vos messages ont Ã©tÃ© conservÃ©s.
ğŸ”™ Retour au menu principal.
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["step"] = "main_menu"
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        else:
            sent_message = await update.message.reply_text("""â“ RÃ©ponse invalide

âœ… Tapez OUI pour confirmer la suppression de TOUS les messages
âŒ Tapez NON pour annuler
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    # Diffusion immÃ©diate
    elif menu_state["step"] == "broadcast_now":
        # Supprimer le message prÃ©cÃ©dent du bot
        if 'last_bot_message_id' in menu_state:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=menu_state['last_bot_message_id']
                )
            except:
                pass
        
        await update.message.reply_text("""ğŸš€ **DIFFUSION EN COURS...**

ğŸ“¤ Envoi de votre message Ã  tous les utilisateurs...
â³ Veuillez patienter...""")
        
        # Effectuer la diffusion avec support mÃ©dia
        result = await send_broadcast_message_with_media(update)
        
        sent_message = await update.message.reply_text(f"""âœ… DIFFUSION TERMINÃ‰E !

ğŸ“Š RÃ©sultats :
âœ… Messages envoyÃ©s : {result['sent_count']}
âŒ Ã‰checs : {result['failed_count']}
ğŸ‘¥ Total utilisateurs : {result['total_users']}

ğŸ”™ Retour au menu :

1ï¸âƒ£ Ajouter message
2ï¸âƒ£ Voir messages
3ï¸âƒ£ Supprimer message
4ï¸âƒ£ Supprimer tous
5ï¸âƒ£ Diffuser Ã  nouveau
6ï¸âƒ£ Statistiques  
7ï¸âƒ£ Quitter
ğŸšª **SORTIR** - Tapez SORTIR pour quitter le menu

ğŸ“ Tapez votre choix :""")
        
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_broadcast_process(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re le processus de diffusion en plusieurs Ã©tapes"""
    user_id = update.effective_user.id
    message_text = update.message.text if update.message.text else ""

    if user_id not in broadcast_states:
        return

    current_state = broadcast_states[user_id]

    # Ã‰tape 1 : RÃ©ception du message Ã  diffuser
    if current_state["step"] == "waiting_message":
        # DÃ©terminer le type de contenu
        if update.message.photo:
            current_state["media_type"] = "photo"
            current_state["media_file"] = update.message.photo[-1].file_id
            current_state["message"] = update.message.caption or ""
        elif update.message.video:
            current_state["media_type"] = "video"
            current_state["media_file"] = update.message.video.file_id
            current_state["message"] = update.message.caption or ""
        elif update.message.document:
            current_state["media_type"] = "document"
            current_state["media_file"] = update.message.document.file_id
            current_state["message"] = update.message.caption or ""
        else:
            current_state["media_type"] = "text"
            current_state["media_file"] = None
            current_state["message"] = message_text

        current_state["step"] = "waiting_confirmation"

        # Afficher le preview
        media_info = ""
        if current_state["media_type"] != "text":
            media_info = f"ğŸï¸ **Type de mÃ©dia :** {current_state['media_type'].upper()}\n"

        preview_message = f"""ğŸ“¢ **APERÃ‡U DU MESSAGE Ã€ DIFFUSER**

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{media_info}{current_state['message']}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š **Informations de diffusion :**
ğŸ‘‘ ExpÃ©diteur : **SIHO ISAAC ROLAND**
ğŸ‘¥ Destinataires : Tous les utilisateurs inscrits
ğŸ“… Date d'envoi : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}

âš ï¸ **Ã‰tape 2/3 :** Voulez-vous vraiment envoyer ce message Ã  tous vos utilisateurs ?

âœ… Tapez **OUI** pour confirmer l'envoi
âŒ Tapez **NON** pour annuler la diffusion"""

        await update.message.reply_text(preview_message)

    # Ã‰tape 2 : Traitement de la confirmation
    elif current_state["step"] == "waiting_confirmation":
        if message_text.upper() == "OUI":
            # Lancer la diffusion
            current_state["step"] = "sending"

            await update.message.reply_text("""ğŸš€ **DIFFUSION EN COURS...**

ğŸ“¤ Envoi du message Ã  tous les utilisateurs...
â³ Veuillez patienter...""")

            # Effectuer la diffusion
            result = await send_broadcast_with_media(current_state)

            # Afficher le rÃ©sultat
            success_message = f"""âœ… **DIFFUSION TERMINÃ‰E !**

ğŸ“Š **Rapport d'envoi :**
âœ… Messages envoyÃ©s : **{result['sent_count']}**
âŒ Ã‰checs d'envoi : **{result['failed_count']}**
ğŸ‘¥ Total utilisateurs : **{result['total_users']}**
ğŸ“… Date/Heure : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}

ğŸ¯ Votre message a Ã©tÃ© diffusÃ© avec succÃ¨s !"""

            await update.message.reply_text(success_message)

        else:
            # Annuler la diffusion
            await update.message.reply_text("""âŒ **DIFFUSION ANNULÃ‰E**

ğŸš« La diffusion de message a Ã©tÃ© annulÃ©e.
ğŸ“ Votre message n'a pas Ã©tÃ© envoyÃ©.

ğŸ’¡ Utilisez Ã  nouveau `/broadcast` si vous souhaitez diffuser un message.""")

        # Nettoyer l'Ã©tat
        del broadcast_states[user_id]


async def send_broadcast_message_with_media(update):
    """Envoie un message de diffusion avec support mÃ©dia depuis un update"""
    users_data = load_users()
    app = ApplicationBuilder().token(TOKEN).build()

    sent_count = 0
    failed_count = 0
    total_users = len(users_data)

    # DÃ©terminer le type de contenu
    message_text = ""
    media_type = "text"
    media_file_id = None

    if update.message.photo:
        media_type = "photo"
        media_file_id = update.message.photo[-1].file_id
        message_text = update.message.caption or ""
    elif update.message.video:
        media_type = "video"
        media_file_id = update.message.video.file_id
        message_text = update.message.caption or ""
    elif update.message.document:
        media_type = "document"
        media_file_id = update.message.document.file_id
        message_text = update.message.caption or ""
    else:
        message_text = update.message.text or ""

    # Ajouter l'en-tÃªte ZACK PCS au message
    formatted_message = f"""ğŸ“¢ **MESSAGE OFFICIEL ZACK PCS**

{message_text}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Code promo : **{PROMO_CODE}**
ğŸ“± Support : {CONTACT_LINK}
ğŸ“š Infos : {INFO_LINK}"""

    # Envoyer Ã  tous les utilisateurs
    for user_id, user_data in users_data.items():
        try:
            if media_type == "photo":
                await app.bot.send_photo(
                    chat_id=int(user_id), 
                    photo=media_file_id, 
                    caption=formatted_message
                )
            elif media_type == "video":
                await app.bot.send_video(
                    chat_id=int(user_id), 
                    video=media_file_id, 
                    caption=formatted_message
                )
            elif media_type == "document":
                await app.bot.send_document(
                    chat_id=int(user_id), 
                    document=media_file_id, 
                    caption=formatted_message
                )
            else:
                await app.bot.send_message(
                    chat_id=int(user_id), 
                    text=formatted_message
                )
            
            sent_count += 1
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            await asyncio.sleep(0.5)

        except Exception as e:
            print(f"Erreur envoi diffusion Ã  {user_id}: {e}")
            failed_count += 1

    save_users(users_data)
    return {
        "sent_count": sent_count,
        "failed_count": failed_count,
        "total_users": total_users
    }


async def send_broadcast_with_media(broadcast_state):
    """Envoie un message de diffusion avec support mÃ©dia depuis un Ã©tat de diffusion"""
    users_data = load_users()
    app = ApplicationBuilder().token(TOKEN).build()

    sent_count = 0
    failed_count = 0
    total_users = len(users_data)

    # Ajouter l'en-tÃªte ZACK PCS au message
    formatted_message = f"""ğŸ“¢ **MESSAGE OFFICIEL ZACK PCS**

{broadcast_state['message']}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Code promo : **{PROMO_CODE}**
ğŸ“± Support : {CONTACT_LINK}
ğŸ“š Infos : {INFO_LINK}"""

    # Envoyer Ã  tous les utilisateurs
    for user_id, user_data in users_data.items():
        try:
            if broadcast_state['media_type'] == "photo":
                await app.bot.send_photo(
                    chat_id=int(user_id), 
                    photo=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            elif broadcast_state['media_type'] == "video":
                await app.bot.send_video(
                    chat_id=int(user_id), 
                    video=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            elif broadcast_state['media_type'] == "document":
                await app.bot.send_document(
                    chat_id=int(user_id), 
                    document=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            else:
                await app.bot.send_message(
                    chat_id=int(user_id), 
                    text=formatted_message
                )
            
            sent_count += 1
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            await asyncio.sleep(0.5)

        except Exception as e:
            print(f"Erreur envoi diffusion Ã  {user_id}: {e}")
            failed_count += 1

    save_users(users_data)
    return {
        "sent_count": sent_count,
        "failed_count": failed_count,
        "total_users": total_users
    }


async def send_broadcast_message(broadcast_message):
    """Envoie un message de diffusion texte simple (fonction legacy)"""
    users_data = load_users()
    app = ApplicationBuilder().token(TOKEN).build()

    sent_count = 0
    failed_count = 0
    total_users = len(users_data)

    formatted_message = f"""ğŸ“¢ **MESSAGE OFFICIEL ZACK PCS**

{broadcast_message}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Code promo : **{PROMO_CODE}**
ğŸ“± Support : {CONTACT_LINK}
ğŸ“š Infos : {INFO_LINK}"""

    for user_id, user_data in users_data.items():
        try:
            await app.bot.send_message(chat_id=int(user_id), text=formatted_message)
            sent_count += 1
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            await asyncio.sleep(0.5)
        except Exception as e:
            print(f"Erreur envoi diffusion Ã  {user_id}: {e}")
            failed_count += 1

    save_users(users_data)
    return {
        "sent_count": sent_count,
        "failed_count": failed_count,
        "total_users": total_users
    }


def schedule_daily_messages():
    """Programme les messages quotidiens"""
    def run_broadcast():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(broadcast_daily_messages())
        except Exception as e:
            print(f"Erreur lors de l'envoi des messages quotidiens: {e}")
        finally:
            loop.close()

    schedule.every().day.at("09:00").do(run_broadcast)
    schedule.every().day.at("18:00").do(run_broadcast)

    while True:
        schedule.run_pending()
        time.sleep(30)


if __name__ == "__main__":
    print("ğŸš€ DÃ©marrage du bot ZACK PCS...")

    # CrÃ©ation de l'application
    app = ApplicationBuilder().token(TOKEN).build()

    # Ajout des handlers pour texte, images et vidÃ©os
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("stats", stats))
    app.add_handler(CommandHandler("test", send_test_message))
    app.add_handler(CommandHandler("broadcast", broadcast_command))
    
    # Handler pour tous les types de messages (texte, photo, vidÃ©o, document)
    app.add_handler(MessageHandler(
        (filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL) & ~filters.COMMAND, 
        handle_message
    ))

    # DÃ©marrer le scheduler dans un thread sÃ©parÃ©
    scheduler_thread = threading.Thread(target=schedule_daily_messages, daemon=True)
    scheduler_thread.start()

    print("ğŸ¤– Bot ZACK PCS dÃ©marrÃ© ! En attente de nouveaux utilisateurs...")
    print(f"ğŸ“§ Messages automatiques programmÃ©s Ã  9h et 18h")
    print(f"ğŸ”‘ Code promo actif : {PROMO_CODE}")
    print("ğŸ–¼ï¸ Support complet : Texte, Images, VidÃ©os !")

    # DÃ©marrage du bot
    app.run_polling()

