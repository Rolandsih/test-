
import json
import os
import asyncio
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters, CallbackQueryHandler

# Configuration
TOKEN = os.getenv("BOT_TOKEN", "7993065501:AAFUcGkVqk6W2pGYYYrCUhP_fhyzQG7d9qo")
CANAL_LINK = "https://t.me/+6ya0mglfi4A2NGZk"
ADMIN_CODE = "SIHO ISAAC ROLAND 840106"
ADMIN_CHAT_ID = None

# Fichiers de donnÃ©es
USERS_FILE = "users.json"
ADMINS_FILE = "admins.json"
BLOCKED_USERS_FILE = "blocked_users.json"
MESSAGES_FILE = "messages.json"

# Ã‰tats des utilisateurs
user_states = {}

def load_json(file_path, default=None):
    """Charge un fichier JSON"""
    if default is None:
        default = {}
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
    except:
        pass
    return default

def save_json(file_path, data):
    """Sauvegarde un fichier JSON"""
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def load_users():
    return load_json(USERS_FILE, {})

def save_users(data):
    save_json(USERS_FILE, data)

def load_admins():
    return load_json(ADMINS_FILE, {})

def save_admins(data):
    save_json(ADMINS_FILE, data)

def load_blocked_users():
    return load_json(BLOCKED_USERS_FILE, {})

def save_blocked_users(data):
    save_json(BLOCKED_USERS_FILE, data)

def load_messages():
    default_messages = {
        "welcome": "Bonjour {nom} ! ğŸ‰\n\nBienvenue dans notre communautÃ© !\n\nğŸ”— Rejoins notre canal officiel : {canal}\n\nğŸ“ Pour toute question, je suis lÃ  pour t'aider !",
        "auto_hours": ["09:00", "18:00"]
    }
    return load_json(MESSAGES_FILE, default_messages)

def save_messages(data):
    save_json(MESSAGES_FILE, data)

def is_admin(user_id):
    """VÃ©rifie si un utilisateur est admin"""
    global ADMIN_CHAT_ID
    if ADMIN_CHAT_ID and user_id == ADMIN_CHAT_ID:
        return True
    admins = load_admins()
    return str(user_id) in admins

def is_blocked(user_id):
    """VÃ©rifie si un utilisateur est bloquÃ©"""
    blocked = load_blocked_users()
    return str(user_id) in blocked

def clear_user_state(user_id):
    """Nettoie l'Ã©tat d'un utilisateur"""
    if user_id in user_states:
        del user_states[user_id]

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /start - Message de bienvenue personnalisÃ©"""
    user = update.effective_user
    user_id = str(user.id)
    user_name = user.first_name or user.username or "ami"
    
    # Nettoyer l'Ã©tat au dÃ©marrage
    clear_user_state(user.id)
    
    # VÃ©rifier si bloquÃ©
    if is_blocked(user_id):
        await update.message.reply_text("âŒ Votre accÃ¨s a Ã©tÃ© suspendu.")
        return
    
    # Sauvegarder l'utilisateur
    users = load_users()
    users[user_id] = {
        "name": user_name,
        "username": user.username,
        "registered_date": datetime.now().isoformat(),
        "last_activity": datetime.now().isoformat(),
        "message_count": users.get(user_id, {}).get("message_count", 0)
    }
    save_users(users)
    
    # Message de bienvenue personnalisÃ©
    messages = load_messages()
    welcome_text = messages["welcome"].format(nom=user_name, canal=CANAL_LINK)
    
    await update.message.reply_text(welcome_text)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestion des messages texte"""
    user_id = update.effective_user.id
    message_text = update.message.text.strip()
    user_name = update.effective_user.first_name or "utilisateur"
    
    # VÃ©rifier si bloquÃ© (sauf pour l'admin)
    if not is_admin(user_id) and is_blocked(str(user_id)):
        await update.message.reply_text("âŒ Votre accÃ¨s a Ã©tÃ© suspendu.")
        return
    
    # Code admin principal
    if message_text == ADMIN_CODE:
        await handle_admin_login(update)
        return
    
    # Commande /sortir - fonctionne partout
    if message_text == "/sortir":
        clear_user_state(user_id)
        await update.message.reply_text("âœ… Retour au menu principal.")
        return
    
    # Gestion des Ã©tats admin - SEULEMENT pour les admins
    if user_id in user_states and is_admin(user_id):
        await handle_admin_states(update, context)
        return
    
    # Si un non-admin essaie d'accÃ©der aux fonctions admin
    if user_id in user_states and not is_admin(user_id):
        clear_user_state(user_id)
        await update.message.reply_text("âŒ AccÃ¨s non autorisÃ©.")
        return
    
    # Message normal d'utilisateur
    users = load_users()
    if str(user_id) in users:
        users[str(user_id)]["message_count"] += 1
        users[str(user_id)]["last_activity"] = datetime.now().isoformat()
        save_users(users)
    
    await update.message.reply_text(
        f"ğŸ“ Merci {user_name} ! Votre message a Ã©tÃ© reÃ§u.\n\n"
        f"ğŸ”— Rejoignez notre canal : {CANAL_LINK}\n\n"
        f"ğŸ”š Tapez /sortir Ã  tout moment"
    )

async def handle_admin_login(update: Update):
    """Gestion de la connexion admin"""
    global ADMIN_CHAT_ID
    user_id = update.effective_user.id
    ADMIN_CHAT_ID = user_id
    
    # Nettoyer l'Ã©tat
    clear_user_state(user_id)
    
    # Statistiques
    users = load_users()
    blocked = load_blocked_users()
    total_users = len(users)
    blocked_count = len(blocked)
    active_users = total_users - blocked_count
    
    # Menu admin principal
    keyboard = [
        [InlineKeyboardButton("ğŸ“Š Statistiques dÃ©taillÃ©es", callback_data="stats_detail")],
        [InlineKeyboardButton("ğŸ” Rechercher utilisateur", callback_data="search_user")],
        [InlineKeyboardButton("ğŸ“ Modifier message bienvenue", callback_data="modify_welcome")],
        [InlineKeyboardButton("â° Modifier heures d'envoi", callback_data="modify_hours")],
        [InlineKeyboardButton("ğŸ‘¤ Ajouter administrateur", callback_data="add_admin")],
        [InlineKeyboardButton("ğŸ—‘ï¸ Supprimer administrateur", callback_data="del_admin")],
        [InlineKeyboardButton("ğŸš« Bloquer utilisateur", callback_data="block_user")],
        [InlineKeyboardButton("âœ… DÃ©bloquer utilisateur", callback_data="unblock_user")],
        [InlineKeyboardButton("ğŸ”š Quitter", callback_data="exit_admin")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    admin_message = f"""ğŸ” PANNEAU ADMINISTRATEUR
ğŸ‘¤ SIHO ISAAC ROLAND - AccÃ¨s autorisÃ©
ğŸ• Connexion : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}

ğŸ“Š STATISTIQUES RAPIDES
ğŸ‘¥ Utilisateurs totaux : {total_users}
âœ… Utilisateurs actifs : {active_users}
âŒ Utilisateurs bloquÃ©s : {blocked_count}

ğŸ”§ SÃ©lectionnez une action :"""
    
    await update.message.reply_text(admin_message, reply_markup=reply_markup)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestion des boutons inline"""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    data = query.data
    
    # VÃ©rification admin obligatoire
    if not is_admin(user_id):
        await query.edit_message_text("âŒ AccÃ¨s non autorisÃ©.")
        return
    
    if data == "exit_admin":
        clear_user_state(user_id)
        await query.edit_message_text("âœ… Sortie du mode administrateur\n\nVous Ãªtes maintenant en mode utilisateur normal.")
        return
    
    elif data == "back_to_menu":
        await handle_admin_login_callback(query)
        return
    
    elif data == "stats_detail":
        await show_detailed_stats(query)
    
    elif data == "search_user":
        user_states[user_id] = {"action": "search_user"}
        await query.edit_message_text(
            "ğŸ” RECHERCHE D'UTILISATEUR\n\n"
            "ğŸ”¸ Tapez le nom ou @pseudo de l'utilisateur\n"
            "ğŸ”¸ Ou tapez 'liste' pour voir tous les utilisateurs\n\n"
            "ğŸ”š /sortir pour annuler"
        )
    
    elif data == "modify_welcome":
        user_states[user_id] = {"action": "modify_welcome"}
        messages = load_messages()
        current_welcome = messages["welcome"]
        await query.edit_message_text(
            f"ğŸ“ MODIFICATION DU MESSAGE DE BIENVENUE\n\n"
            f"ğŸ“‹ Message actuel :\n{current_welcome}\n\n"
            f"ğŸ“ Variables disponibles :\n"
            f"â€¢ {{nom}} - Nom de l'utilisateur\n"
            f"â€¢ {{canal}} - Lien du canal\n\n"
            f"ğŸ“ Tapez votre nouveau message :\n\n"
            f"ğŸ”š /sortir pour annuler"
        )
    
    elif data == "block_user":
        user_states[user_id] = {"action": "block_user"}
        await query.edit_message_text(
            "ğŸš« BLOQUER UN UTILISATEUR\n\n"
            "ğŸ” Tapez le nom, @pseudo ou ID de l'utilisateur Ã  bloquer :\n\n"
            "ğŸ”š /sortir pour annuler"
        )
    
    elif data == "unblock_user":
        user_states[user_id] = {"action": "unblock_user"}
        await query.edit_message_text(
            "âœ… DÃ‰BLOQUER UN UTILISATEUR\n\n"
            "ğŸ” Tapez le nom, @pseudo ou ID de l'utilisateur Ã  dÃ©bloquer :\n\n"
            "ğŸ”š /sortir pour annuler"
        )

async def handle_admin_login_callback(query):
    """Retour au menu admin principal"""
    user_id = query.from_user.id
    clear_user_state(user_id)
    
    # Statistiques
    users = load_users()
    blocked = load_blocked_users()
    total_users = len(users)
    blocked_count = len(blocked)
    active_users = total_users - blocked_count
    
    # Menu admin principal
    keyboard = [
        [InlineKeyboardButton("ğŸ“Š Statistiques dÃ©taillÃ©es", callback_data="stats_detail")],
        [InlineKeyboardButton("ğŸ” Rechercher utilisateur", callback_data="search_user")],
        [InlineKeyboardButton("ğŸ“ Modifier message bienvenue", callback_data="modify_welcome")],
        [InlineKeyboardButton("â° Modifier heures d'envoi", callback_data="modify_hours")],
        [InlineKeyboardButton("ğŸ‘¤ Ajouter administrateur", callback_data="add_admin")],
        [InlineKeyboardButton("ğŸ—‘ï¸ Supprimer administrateur", callback_data="del_admin")],
        [InlineKeyboardButton("ğŸš« Bloquer utilisateur", callback_data="block_user")],
        [InlineKeyboardButton("âœ… DÃ©bloquer utilisateur", callback_data="unblock_user")],
        [InlineKeyboardButton("ğŸ”š Quitter", callback_data="exit_admin")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    admin_message = f"""ğŸ” PANNEAU ADMINISTRATEUR
ğŸ‘¤ SIHO ISAAC ROLAND - AccÃ¨s autorisÃ©
ğŸ• Connexion : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}

ğŸ“Š STATISTIQUES RAPIDES
ğŸ‘¥ Utilisateurs totaux : {total_users}
âœ… Utilisateurs actifs : {active_users}
âŒ Utilisateurs bloquÃ©s : {blocked_count}

ğŸ”§ SÃ©lectionnez une action :"""
    
    await query.edit_message_text(admin_message, reply_markup=reply_markup)

async def show_detailed_stats(query):
    """Affiche les statistiques dÃ©taillÃ©es"""
    users = load_users()
    blocked = load_blocked_users()
    admins = load_admins()
    
    total_users = len(users)
    blocked_count = len(blocked)
    admin_count = len(admins) + 1  # +1 pour l'admin principal
    
    # Utilisateurs actifs aujourd'hui
    today = datetime.now().date()
    active_today = 0
    for user_data in users.values():
        try:
            last_activity = datetime.fromisoformat(user_data.get("last_activity", "2000-01-01"))
            if last_activity.date() == today:
                active_today += 1
        except:
            pass
    
    # Top 3 utilisateurs les plus actifs
    top_users = sorted(users.items(), key=lambda x: x[1].get("message_count", 0), reverse=True)[:3]
    top_text = ""
    for i, (uid, user_data) in enumerate(top_users, 1):
        name = user_data.get("name", "Inconnu")
        count = user_data.get("message_count", 0)
        top_text += f"{i}. {name} - {count} messages\n"
    
    keyboard = [[InlineKeyboardButton("ğŸ”™ Retour au menu", callback_data="back_to_menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    stats_message = f"""ğŸ“Š STATISTIQUES DÃ‰TAILLÃ‰ES

ğŸ‘¥ Utilisateurs
â”œâ”€â”€ Total : {total_users}
â”œâ”€â”€ Actifs aujourd'hui : {active_today}
â”œâ”€â”€ BloquÃ©s : {blocked_count}
â””â”€â”€ Administrateurs : {admin_count}

ğŸ† TOP UTILISATEURS ACTIFS
{top_text if top_text else "Aucune activitÃ©"}

ğŸ“… Rapport gÃ©nÃ©rÃ© le : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}"""
    
    await query.edit_message_text(stats_message, reply_markup=reply_markup)

async def handle_admin_states(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestion des Ã©tats administrateur"""
    user_id = update.effective_user.id
    message_text = update.message.text.strip()
    
    if user_id not in user_states:
        return
    
    state = user_states[user_id]
    action = state.get("action")
    
    if action == "modify_welcome":
        await handle_welcome_modification(update, message_text)
    
    elif action == "search_user":
        await handle_user_search(update, message_text)
    
    elif action == "block_user":
        await handle_user_blocking(update, message_text)
    
    elif action == "unblock_user":
        await handle_user_unblocking(update, message_text)
    
    elif action == "view_user_details":
        await handle_user_details_view(update, message_text)

async def handle_welcome_modification(update: Update, new_message: str):
    """Modifie le message de bienvenue"""
    messages = load_messages()
    messages["welcome"] = new_message
    save_messages(messages)
    
    user_id = update.effective_user.id
    clear_user_state(user_id)
    
    preview = new_message.format(nom="[Nom]", canal=CANAL_LINK)
    
    await update.message.reply_text(
        f"âœ… MESSAGE DE BIENVENUE MODIFIÃ‰\n\n"
        f"ğŸ“ AperÃ§u :\n{preview}\n\n"
        f"ğŸ“… ModifiÃ© le : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}\n\n"
        f"ğŸ”š /sortir pour quitter"
    )

async def handle_user_search(update: Update, search_term: str):
    """GÃ¨re la recherche d'utilisateurs"""
    users = load_users()
    
    if search_term.lower() == "liste":
        await show_users_list(update, users)
        return
    
    # VÃ©rifier si c'est un numÃ©ro (sÃ©lection d'utilisateur)
    try:
        user_number = int(search_term)
        if user_number > 0:
            await handle_user_selection(update, user_number)
            return
    except ValueError:
        pass
    
    # Rechercher par nom, pseudo ou ID
    found_users = []
    for uid, user_data in users.items():
        name = user_data.get("name", "").lower()
        username = user_data.get("username", "").lower() if user_data.get("username") else ""
        
        if (search_term.lower() in name or 
            search_term.lower() in username or
            search_term == uid):
            found_users.append((uid, user_data))
    
    if not found_users:
        await update.message.reply_text(
            f"âŒ AUCUN UTILISATEUR TROUVÃ‰\n\n"
            f"ğŸ” Aucun rÃ©sultat pour : \"{search_term}\"\n\n"
            f"ğŸ”„ Tapez un autre terme\n"
            f"ğŸ“„ Ou tapez 'liste' pour voir tous\n\n"
            f"ğŸ”š /sortir pour quitter"
        )
        return
    
    # Afficher les rÃ©sultats numÃ©rotÃ©s
    result_text = f"ğŸ” RÃ‰SULTATS POUR : {search_term}\n\n"
    
    for i, (uid, user_data) in enumerate(found_users[:10], 1):
        name = user_data.get("name", "Inconnu")
        username = user_data.get("username", "N/A")
        status = "ğŸš« BloquÃ©" if is_blocked(uid) else "âœ… Actif"
        result_text += f"{i}. {name} (@{username})\n    ID: {uid} | {status}\n\n"
    
    result_text += "ğŸ“ Tapez le numÃ©ro pour voir les dÃ©tails\n\nğŸ”š /sortir pour quitter"
    
    # Sauvegarder les rÃ©sultats dans l'Ã©tat
    user_states[update.effective_user.id]["found_users"] = found_users
    user_states[update.effective_user.id]["action"] = "view_user_details"
    
    await update.message.reply_text(result_text)

async def handle_user_selection(update: Update, user_number: int):
    """GÃ¨re la sÃ©lection d'un utilisateur par numÃ©ro"""
    user_id = update.effective_user.id
    
    if user_id not in user_states or "found_users" not in user_states[user_id]:
        await update.message.reply_text(
            "âŒ ERREUR\n\nAucune liste d'utilisateurs disponible.\n\nğŸ”š /sortir pour quitter"
        )
        return
    
    found_users = user_states[user_id]["found_users"]
    
    if user_number < 1 or user_number > len(found_users):
        await update.message.reply_text(
            f"âŒ NUMÃ‰RO INVALIDE\n\nChoisissez un numÃ©ro entre 1 et {len(found_users)}\n\nğŸ”š /sortir pour quitter"
        )
        return
    
    # Afficher les dÃ©tails de l'utilisateur sÃ©lectionnÃ©
    uid, user_data = found_users[user_number - 1]
    await show_user_details(update, uid, user_data)

async def handle_user_details_view(update: Update, message_text: str):
    """GÃ¨re la visualisation des dÃ©tails utilisateur"""
    try:
        user_number = int(message_text)
        await handle_user_selection(update, user_number)
    except ValueError:
        await update.message.reply_text(
            "âŒ SAISIE INVALIDE\n\nTapez le numÃ©ro de l'utilisateur Ã  consulter\n\nğŸ”š /sortir pour quitter"
        )

async def show_user_details(update: Update, uid: str, user_data: dict):
    """Affiche les dÃ©tails d'un utilisateur"""
    name = user_data.get("name", "Inconnu")
    username = user_data.get("username", "N/A")
    registered = user_data.get("registered_date", "N/A")
    last_activity = user_data.get("last_activity", "N/A")
    message_count = user_data.get("message_count", 0)
    
    try:
        reg_date = datetime.fromisoformat(registered).strftime('%d/%m/%Y Ã  %H:%M')
    except:
        reg_date = "Date inconnue"
    
    try:
        last_act = datetime.fromisoformat(last_activity).strftime('%d/%m/%Y Ã  %H:%M')
    except:
        last_act = "ActivitÃ© inconnue"
    
    status = "ğŸš« BLOQUÃ‰" if is_blocked(uid) else "âœ… ACTIF"
    
    details_text = f"""ğŸ‘¤ DÃ‰TAILS UTILISATEUR

ğŸ”¹ Nom : {name}
ğŸ”¹ Username : @{username}
ğŸ”¹ ID Telegram : {uid}
ğŸ”¹ Statut : {status}
ğŸ”¹ Inscrit le : {reg_date}
ğŸ”¹ DerniÃ¨re activitÃ© : {last_act}
ğŸ”¹ Messages envoyÃ©s : {message_count}

ğŸ”š /sortir pour retourner au menu"""
    
    clear_user_state(update.effective_user.id)
    await update.message.reply_text(details_text)

async def show_users_list(update: Update, users: dict):
    """Affiche la liste complÃ¨te des utilisateurs"""
    if not users:
        await update.message.reply_text(
            "ğŸ“­ AUCUN UTILISATEUR ENREGISTRÃ‰\n\nğŸ”š /sortir pour quitter"
        )
        return
    
    users_text = "ğŸ‘¥ LISTE DES UTILISATEURS\n\n"
    
    users_list = list(users.items())
    for i, (uid, user_data) in enumerate(users_list[:20], 1):
        name = user_data.get("name", "Inconnu")
        status = "ğŸš«" if is_blocked(uid) else "âœ…"
        users_text += f"{i}. {status} {name}\n"
    
    if len(users) > 20:
        users_text += f"\n... et {len(users) - 20} autres utilisateurs"
    
    users_text += f"\n\nğŸ“Š Total : {len(users)} utilisateurs\n\n"
    users_text += "ğŸ“ Tapez le numÃ©ro pour voir les dÃ©tails\n\nğŸ”š /sortir pour quitter"
    
    # Sauvegarder la liste dans l'Ã©tat
    user_states[update.effective_user.id]["found_users"] = users_list
    user_states[update.effective_user.id]["action"] = "view_user_details"
    
    await update.message.reply_text(users_text)

async def handle_user_blocking(update: Update, search_term: str):
    """GÃ¨re le blocage d'utilisateurs"""
    users = load_users()
    blocked = load_blocked_users()
    
    # Rechercher l'utilisateur
    found_user = None
    for uid, user_data in users.items():
        name = user_data.get("name", "").lower()
        username = user_data.get("username", "").lower() if user_data.get("username") else ""
        
        if (search_term.lower() in name or 
            search_term.lower() in username or
            search_term == uid):
            found_user = (uid, user_data)
            break
    
    if not found_user:
        await update.message.reply_text(
            f"âŒ UTILISATEUR NON TROUVÃ‰\n\n"
            f"ğŸ” Aucun rÃ©sultat pour : \"{search_term}\"\n\n"
            f"ğŸ”„ Tapez un autre terme\n\n"
            f"ğŸ”š /sortir pour annuler"
        )
        return
    
    uid, user_data = found_user
    
    if uid in blocked:
        await update.message.reply_text(
            f"âš ï¸ UTILISATEUR DÃ‰JÃ€ BLOQUÃ‰\n\n"
            f"ğŸ‘¤ {user_data.get('name', 'Inconnu')} est dÃ©jÃ  bloquÃ©.\n\n"
            f"ğŸ”š /sortir pour quitter"
        )
        return
    
    # Bloquer l'utilisateur
    blocked[uid] = {
        "blocked_date": datetime.now().isoformat(),
        "blocked_by": update.effective_user.id,
        "name": user_data.get("name", "Inconnu")
    }
    save_blocked_users(blocked)
    
    # Nettoyer l'Ã©tat
    clear_user_state(update.effective_user.id)
    
    await update.message.reply_text(
        f"ğŸš« UTILISATEUR BLOQUÃ‰ AVEC SUCCÃˆS\n\n"
        f"ğŸ‘¤ {user_data.get('name', 'Inconnu')} a Ã©tÃ© bloquÃ©.\n"
        f"ğŸ• Date : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}\n\n"
        f"âœ… L'utilisateur ne pourra plus utiliser le bot.\n\n"
        f"ğŸ”š /sortir pour quitter"
    )

async def handle_user_unblocking(update: Update, search_term: str):
    """GÃ¨re le dÃ©blocage d'utilisateurs"""
    blocked = load_blocked_users()
    
    if not blocked:
        await update.message.reply_text(
            "â„¹ï¸ AUCUN UTILISATEUR BLOQUÃ‰\n\n"
            "Il n'y a actuellement aucun utilisateur bloquÃ©.\n\n"
            "ğŸ”š /sortir pour quitter"
        )
        clear_user_state(update.effective_user.id)
        return
    
    # Rechercher l'utilisateur bloquÃ©
    found_blocked = None
    for uid, blocked_data in blocked.items():
        name = blocked_data.get("name", "").lower()
        
        if (search_term.lower() in name or search_term == uid):
            found_blocked = (uid, blocked_data)
            break
    
    if not found_blocked:
        await update.message.reply_text(
            f"âŒ UTILISATEUR BLOQUÃ‰ NON TROUVÃ‰\n\n"
            f"ğŸ” Aucun rÃ©sultat pour : \"{search_term}\"\n\n"
            f"ğŸ”„ Tapez un autre terme\n\n"
            f"ğŸ”š /sortir pour annuler"
        )
        return
    
    uid, blocked_data = found_blocked
    
    # DÃ©bloquer l'utilisateur
    del blocked[uid]
    save_blocked_users(blocked)
    
    # Nettoyer l'Ã©tat
    clear_user_state(update.effective_user.id)
    
    await update.message.reply_text(
        f"âœ… UTILISATEUR DÃ‰BLOQUÃ‰ AVEC SUCCÃˆS\n\n"
        f"ğŸ‘¤ {blocked_data.get('name', 'Inconnu')} a Ã©tÃ© dÃ©bloquÃ©.\n"
        f"ğŸ• Date : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}\n\n"
        f"âœ… L'utilisateur peut maintenant utiliser le bot.\n\n"
        f"ğŸ”š /sortir pour quitter"
    )

def main():
    """Fonction principale"""
    print("ğŸš€ DÃ©marrage du Bot Administrateur AvancÃ©...")
    
    # CrÃ©er l'application
    app = Application.builder().token(TOKEN).build()
    
    # Ajouter les handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(handle_callback))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    print(f"âœ… Bot dÃ©marrÃ© avec le canal : {CANAL_LINK}")
    print(f"ğŸ” Code admin : {ADMIN_CODE}")
    print("ğŸ”§ FonctionnalitÃ©s disponibles :")
    print("   - Message de bienvenue personnalisÃ©")
    print("   - Gestion complÃ¨te des utilisateurs")
    print("   - Interface admin avec boutons")
    print("   - Recherche d'utilisateurs")
    print("   - SystÃ¨me de blocage/dÃ©blocage")
    print("   - Statistiques dÃ©taillÃ©es")
    print("   - AccÃ¨s admin sÃ©curisÃ©")
    
    # DÃ©marrer le bot
    app.run_polling()

if __name__ == "__main__":
    main()
