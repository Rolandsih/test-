
import json
import os
import asyncio
import schedule
import time
from datetime import datetime, timedelta
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
import threading

TOKEN = "7997467039:AAF86L8qutp9OzG8K5Hfwh1LG4cePd6BPas"
PROMO_CODE = "SANA33"
CONTACT_LINK = "https://t.me/ZACKCASH22"
DATA_FILE = "users.json"
MESSAGES_FILE = "saved_messages.json"
ADMINS_FILE = "admins.json"
BLOCKED_USERS_FILE = "blocked_users.json"
SETTINGS_FILE = "bot_settings.json"
ADMIN_CHAT_ID = None  # Sera dÃ©fini automatiquement lors de la premiÃ¨re connexion admin

# SystÃ¨me de gestion d'Ã©tats pour la diffusion
broadcast_states = {}

# NOUVELLES FONCTIONNALITÃ‰S RÃ‰VOLUTIONNAIRES
user_analytics = {}
loyalty_points = {}
smart_recommendations = {}
link_tracking = {}

# Liens officiels ZACK PCS
INFO_LINK = "https://bot9082.github.io/Info-/"
TIPS_LINK = "https://bot9082.github.io/ZACK-CASH/"
PLATFORM_LINK = "https://1wlucb.life/casino/list/4?p=169j"

# Fichiers pour les nouvelles fonctionnalitÃ©s
ANALYTICS_FILE = "user_analytics.json"
LOYALTY_FILE = "loyalty_points.json"
TRACKING_FILE = "link_tracking.json"
RECOMMENDATIONS_FILE = "smart_recommendations.json"

# Messages rotatifs personnalisÃ©s ZACK PCS
DAILY_MESSAGES = [
    """Hey {name} !  

ğŸ“Œ ZACK PCS - StratÃ©gies Casino Officielles ğŸ¯

ğŸ° Nouvelle astuce Aviator dÃ©tectÃ©e aujourd'hui !
â° Heures favorables : 14h-16h et 20h-22h
ğŸ”¥ Faille sur roulette europÃ©enne confirmÃ©e !
ğŸ’ Machines Ã  sous : patterns identifiÃ©s sur Book of Ra

ğŸ“š Infos complÃ¨tes : {info_link}
ğŸ“„ Astuces du jour : {tips_link}
ğŸ² Plateforme recommandÃ©e 1win : {platform_link}

ğŸ”‘ Code promo : **{promo}** pour activer tous les avantages !
ğŸ’¬ Support ZACK : {contact}""",

    """Salut {name} !  

ğŸ¯ ZACK PCS - Mise Ã  jour stratÃ©gies ğŸš€

ğŸ’° Gains observÃ©s : +850â‚¬ en 3h avec nos mÃ©thodes !
âš¡ Nouveau schÃ©ma dÃ©tectÃ© sur Crazy Time !
ğŸ² Roulette : mise sur secteurs chauds = 73% rÃ©ussite
ğŸ° Aviator : coefficient optimal entre x1.4 et x2.1

ğŸ“– Guide complet : {info_link}
ğŸ”¥ DerniÃ¨res astuces : {tips_link}
ğŸ† Inscription 1win : {platform_link}

âœ… Code **{promo}** = retraits rapides + bonus exclusifs
ğŸ“± Contact direct : {contact}""",

    """Hey {name} !  

ğŸ”¥ ZACK PCS - Alertes Failles Casino âš ï¸

ğŸ° URGENT : Faille Sweet Bonanza active jusqu'Ã  minuit !
ğŸ’ Machines progressives : jackpots prÃ¨s d'exploser !
ğŸ² Roulette live : dealer favorable identifiÃ© salle 3
â­ Aviator : algorithme prÃ©visible entre 18h-20h

ğŸ“‹ ProcÃ©dures dÃ©taillÃ©es : {info_link}
ğŸ’¯ StratÃ©gies actualisÃ©es : {tips_link}
ğŸ¯ Plateforme sÃ©curisÃ©e : {platform_link}

ğŸ”‘ OBLIGATOIRE : Code **{promo}** pour accÃ¨s complet
ğŸ“ Aide personnalisÃ©e : {contact}""",

    """Bonjour {name} !  

ğŸ’¸ ZACK PCS - RÃ©sultats Exceptionnels ğŸ“Š

ğŸš€ Record battu : +1,200â‚¬ en une session !
ğŸ° Aviator : 9 gains consÃ©cutifs avec notre timing
ğŸ”¥ Blackjack live : stratÃ©gie optimisÃ©e = 68% victoires
ğŸ’ Slots volatiles : moments idÃ©aux pour jouer gros

ğŸ“š MÃ©thodes complÃ¨tes : {info_link}
âš¡ Tips actualisÃ©s : {tips_link}
ğŸ… Compte optimisÃ© 1win : {platform_link}

âœ¨ Code **{promo}** = avantages VIP instantanÃ©s
ğŸ’¬ Questions ? Ã‰cris : {contact}""",

    """Coucou {name} !  

â­ ZACK PCS - OpportunitÃ©s LimitÃ©es â³

ğŸ¯ DERNIÃˆRES 6H : Faille mega jackpot disponible !
ğŸ’° Gains moyens constatÃ©s : +650â‚¬/jour avec nos tips
ğŸ² Roulette franÃ§aise : sÃ©rie rouge/noir prÃ©visible
ğŸ° Gates of Olympus : multiplicateurs x500 frÃ©quents

ğŸ“– AccÃ¨s formations : {info_link}
ğŸ”¥ Astuces temps rÃ©el : {tips_link}
ğŸª Interface optimale : {platform_link}

ğŸ”‘ Code magique **{promo}** pour dÃ©bloquer tout
ğŸ“² Support expert : {contact}""",

    """Bonsoir {name} ! ğŸŒ™

ğŸ² ZACK PCS - Session Nocturne SpÃ©ciale 
ğŸ¦‰ Les nuits sont les plus rentables sur 1win !
ğŸ° Aviator : moins de concurrence = plus de gains
ğŸ’° Roulette after midnight : tendances prÃ©visibles
ğŸ”¥ Bonus nocturnes jusqu'Ã  +200% disponibles !

ğŸ“Š Stats prouvÃ©es : +40% gains de 22h Ã  2h
âš¡ Multiplicateurs frÃ©quents dÃ©tectÃ©s
ğŸ¯ Jackpots progressifs : seuils critiques atteints

ğŸ“š Guide nocturne : {info_link}
ğŸ”¥ StratÃ©gies nuit : {tips_link}
ğŸŒ™ Session optimale : {platform_link}

ğŸ”‘ Code nuit **{promo}** = bonus supplÃ©mentaires
ğŸ’¬ Support 24h/7j : {contact}""",

    """Hello {name} ! ğŸ‘‹

ğŸš¨ ZACK PCS - Alerte Gains Exceptionnels 
ğŸ’¥ BREAKING : Nouveau record Ã©tabli +2,400â‚¬ !
ğŸ° Technique secrÃ¨te rÃ©vÃ©lÃ©e aujourd'hui uniquement
ğŸ”¥ 5 utilisateurs ont dÃ©passÃ© 1000â‚¬ cette semaine
âš¡ Pattern exceptionnel dÃ©couvert sur Plinko

ğŸ¯ RÃ©sultats cette semaine :
â€¢ Aviator : 89% de rÃ©ussite
â€¢ Roulette : 76% sur nos secteurs
â€¢ Slots : x1000+ atteints 3 fois

ğŸ“– MÃ©thode complÃ¨te : {info_link}
ğŸ”¥ Techniques avancÃ©es : {tips_link}
ğŸ† Plateforme premium : {platform_link}

ğŸ”‘ Code VIP **{promo}** = accÃ¨s prioritaire
ğŸ“ Coaching perso : {contact}""",

    """Yo {name} ! ğŸ”¥

âš¡ ZACK PCS - Flash Info Casino 
ğŸ¯ URGENT : Maintenance 1win prÃ©vue demain 14h !
ğŸ’° Profitez maintenant avant l'interruption
ğŸ° Aviator : coefficient x25 observÃ© 3 fois aujourd'hui  
ğŸ”¥ Sweet Bonanza : free spins en masse dÃ©tectÃ©s

â° CrÃ©neaux optimaux restants :
â€¢ 16h-18h : Roulette europÃ©enne  
â€¢ 19h-21h : Machines volatiles
â€¢ 22h-00h : Aviator premium

ğŸ“š StratÃ©gies flash : {info_link}
âš¡ Tips minute : {tips_link}
ğŸ² AccÃ¨s direct : {platform_link}

ğŸ”‘ Code flash **{promo}** = bonus immÃ©diat
ğŸ’¬ Urgence ? Contacte : {contact}"""
]


def load_users():
    """Charge les utilisateurs depuis le fichier JSON"""
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_users(users_data):
    """Sauvegarde les utilisateurs dans le fichier JSON"""
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump(users_data, f, ensure_ascii=False, indent=2)


def load_saved_messages():
    """Charge les messages sauvegardÃ©s depuis le fichier JSON"""
    if os.path.exists(MESSAGES_FILE):
        try:
            with open(MESSAGES_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return []
    return []


def save_messages(messages_data):
    """Sauvegarde les messages dans le fichier JSON"""
    with open(MESSAGES_FILE, 'w', encoding='utf-8') as f:
        json.dump(messages_data, f, ensure_ascii=False, indent=2)


def load_admins():
    """Charge les administrateurs depuis le fichier JSON"""
    if os.path.exists(ADMINS_FILE):
        try:
            with open(ADMINS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_admins(admins_data):
    """Sauvegarde les administrateurs dans le fichier JSON"""
    with open(ADMINS_FILE, 'w', encoding='utf-8') as f:
        json.dump(admins_data, f, ensure_ascii=False, indent=2)


def load_blocked_users():
    """Charge les utilisateurs bloquÃ©s depuis le fichier JSON"""
    if os.path.exists(BLOCKED_USERS_FILE):
        try:
            with open(BLOCKED_USERS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_blocked_users(blocked_data):
    """Sauvegarde les utilisateurs bloquÃ©s dans le fichier JSON"""
    with open(BLOCKED_USERS_FILE, 'w', encoding='utf-8') as f:
        json.dump(blocked_data, f, ensure_ascii=False, indent=2)


def load_bot_settings():
    """Charge les paramÃ¨tres du bot depuis le fichier JSON"""
    if os.path.exists(SETTINGS_FILE):
        try:
            with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {"morning_time": "09:00", "evening_time": "18:00"}
    return {"morning_time": "09:00", "evening_time": "18:00"}


def save_bot_settings(settings_data):
    """Sauvegarde les paramÃ¨tres du bot dans le fichier JSON"""
    with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
        json.dump(settings_data, f, ensure_ascii=False, indent=2)


# NOUVELLES FONCTIONS RÃ‰VOLUTIONNAIRES
def load_analytics():
    """Charge les analytics des utilisateurs"""
    if os.path.exists(ANALYTICS_FILE):
        try:
            with open(ANALYTICS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_analytics(analytics_data):
    """Sauvegarde les analytics des utilisateurs"""
    with open(ANALYTICS_FILE, 'w', encoding='utf-8') as f:
        json.dump(analytics_data, f, ensure_ascii=False, indent=2)


def load_loyalty_points():
    """Charge les points de fidÃ©litÃ©"""
    if os.path.exists(LOYALTY_FILE):
        try:
            with open(LOYALTY_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_loyalty_points(loyalty_data):
    """Sauvegarde les points de fidÃ©litÃ©"""
    with open(LOYALTY_FILE, 'w', encoding='utf-8') as f:
        json.dump(loyalty_data, f, ensure_ascii=False, indent=2)


def load_link_tracking():
    """Charge le tracking des liens"""
    if os.path.exists(TRACKING_FILE):
        try:
            with open(TRACKING_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_link_tracking(tracking_data):
    """Sauvegarde le tracking des liens"""
    with open(TRACKING_FILE, 'w', encoding='utf-8') as f:
        json.dump(tracking_data, f, ensure_ascii=False, indent=2)


def update_user_analytics(user_id, action):
    """Met Ã  jour les analytics d'un utilisateur"""
    analytics = load_analytics()
    if user_id not in analytics:
        analytics[user_id] = {
            "total_interactions": 0,
            "commands_used": {},
            "active_days": [],
            "favorite_features": {},
            "last_activity": None,
            "join_date": datetime.now().isoformat(),
            "engagement_score": 0
        }
    
    analytics[user_id]["total_interactions"] += 1
    analytics[user_id]["last_activity"] = datetime.now().isoformat()
    
    today = datetime.now().strftime('%Y-%m-%d')
    if today not in analytics[user_id]["active_days"]:
        analytics[user_id]["active_days"].append(today)
    
    if action not in analytics[user_id]["commands_used"]:
        analytics[user_id]["commands_used"][action] = 0
    analytics[user_id]["commands_used"][action] += 1
    
    # Calcul du score d'engagement
    analytics[user_id]["engagement_score"] = len(analytics[user_id]["active_days"]) * 10 + analytics[user_id]["total_interactions"]
    
    save_analytics(analytics)


def add_loyalty_points(user_id, points, reason):
    """Ajoute des points de fidÃ©litÃ© Ã  un utilisateur"""
    loyalty = load_loyalty_points()
    if user_id not in loyalty:
        loyalty[user_id] = {
            "total_points": 0,
            "level": "Bronze",
            "badges": [],
            "history": [],
            "rewards_claimed": []
        }
    
    loyalty[user_id]["total_points"] += points
    loyalty[user_id]["history"].append({
        "date": datetime.now().isoformat(),
        "points": points,
        "reason": reason
    })
    
    # SystÃ¨me de niveaux
    total = loyalty[user_id]["total_points"]
    if total >= 1000:
        loyalty[user_id]["level"] = "Diamond"
    elif total >= 500:
        loyalty[user_id]["level"] = "Gold"
    elif total >= 200:
        loyalty[user_id]["level"] = "Silver"
    else:
        loyalty[user_id]["level"] = "Bronze"
    
    save_loyalty_points(loyalty)


def get_smart_recommendation(user_id):
    """GÃ©nÃ¨re une recommandation intelligente basÃ©e sur l'activitÃ©"""
    analytics = load_analytics()
    if user_id not in analytics:
        return None
    
    user_data = analytics[user_id]
    most_used = max(user_data["commands_used"], key=user_data["commands_used"].get) if user_data["commands_used"] else None
    
    recommendations = {
        "start": "ğŸ¯ Tu sembles nouveau ! Essaie `/test` pour voir nos stratÃ©gies en action",
        "test": f"ğŸ”¥ Tu adores nos astuces ! Utilise le code **{PROMO_CODE}** sur la plateforme",
        "stats": "ğŸ“Š Tu aimes les chiffres ! Regarde nos analytics sur {TIPS_LINK}",
        "help": "ğŸ’¡ Tu cherches de l'aide ? Contacte directement {CONTACT_LINK}",
    }
    
    return recommendations.get(most_used, "ğŸš€ Continue comme Ã§a, les gains vont exploser !")


def generate_ai_response(user_message, user_id):
    """GÃ©nÃ¨re une rÃ©ponse IA basÃ©e sur le contexte utilisateur"""
    analytics = load_analytics()
    loyalty = load_loyalty_points()
    
    user_level = "Bronze"
    user_points = 0
    
    if user_id in loyalty:
        user_level = loyalty[user_id]["level"]
        user_points = loyalty[user_id]["total_points"]
    
    message_lower = user_message.lower()
    
    # RÃ©ponses intelligentes basÃ©es sur le profil utilisateur
    if any(word in message_lower for word in ["aviator", "avion", "crash"]):
        return f"""ğŸ¯ EXPERT AVIATOR ZACK PCS

{user_level} Member ({user_points} pts) - StratÃ©gie personnalisÃ©e :

ğŸš€ Coefficients optimaux dÃ©tectÃ©s :
â€¢ Mode conservateur : x1.2-x1.5 (85% rÃ©ussite)
â€¢ Mode Ã©quilibrÃ© : x1.8-x2.3 (67% rÃ©ussite) 
â€¢ Mode agressif : x3.0+ (32% rÃ©ussite mais gros gains)

â° Heures favorables aujourd'hui : 16h-18h et 21h-23h
ğŸ’ Pattern dÃ©tectÃ© : SÃ©ries de 3-4 petits multiplicateurs puis gros coup !

ğŸ”‘ Code **{PROMO_CODE}** = cashback 15% sur Aviator
ğŸª Plateforme optimale : {PLATFORM_LINK}"""

    elif any(word in message_lower for word in ["roulette", "rouge", "noir", "numÃ©ro"]):
        return f"""ğŸ² MAÃTRE ROULETTE ZACK PCS

{user_level} VIP ({user_points} pts) - Intel exclusive :

ğŸ”¥ SECTEURS CHAUDS actuels :
â€¢ Tiers du cylindre (27,13,36,11,30,8,23,10,5,24,16,33)
â€¢ Mise sur 19-36 : 73% rÃ©ussite observÃ©e
â€¢ Couleur rouge : sÃ©rie favorable dÃ©tectÃ©e

ğŸ“Š Statistiques temps rÃ©el :
â€¢ ZÃ©ro sorti il y a 12 spins â†’ OpportunitÃ© !
â€¢ DerniÃ¨res tendances : Rouge x6, Pair x4

ğŸ¯ StratÃ©gie recommandÃ©e : Martingale modifiÃ©e sur Rouge
ğŸ’° Bankroll suggÃ©rÃ©e : Mise progressive 5-10-20-40â‚¬"""

    elif any(word in message_lower for word in ["machine", "slot", "jackpot", "bonus"]):
        return f"""ğŸ° SLOTS MASTER ZACK PCS

{user_level} Player ({user_points} pts) - Failles dÃ©tectÃ©es :

ğŸ’ MACHINES HOT actuellement :
â€¢ Book of Ra Deluxe : Bonus round frÃ©quents (18%)
â€¢ Sweet Bonanza : Free spins x500+ possibles
â€¢ Gates of Olympus : Multiplicateurs gÃ©ants actifs

âš¡ TIMING OPTIMAL :
â€¢ 14h-16h : Machines progressives rechargÃ©es
â€¢ 20h-22h : Jackpots proches explosion
â€¢ 02h-04h : RTP maximal observÃ©

ğŸ”¥ ASTUCE SECRÃˆTE : Changer de machine aprÃ¨s 3 spins perdants !
ğŸ Bonus exclusif {user_level} : +50 free spins avec {PROMO_CODE}"""

    return None  # Si aucune rÃ©ponse IA trouvÃ©e


def is_admin(user_id):
    """VÃ©rifie si un utilisateur est administrateur"""
    global ADMIN_CHAT_ID
    if ADMIN_CHAT_ID and user_id == ADMIN_CHAT_ID:
        return True
    
    admins = load_admins()
    return str(user_id) in admins


def is_user_blocked(user_id):
    """VÃ©rifie si un utilisateur est bloquÃ©"""
    blocked_users = load_blocked_users()
    return str(user_id) in blocked_users


def get_user_name(update: Update):
    """RÃ©cupÃ¨re le nom/pseudo de l'utilisateur"""
    user = update.effective_user
    if user.first_name:
        return user.first_name
    elif user.username:
        return user.username
    else:
        return "ami"


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /start - Accueille et enregistre l'utilisateur avec systÃ¨me de fidÃ©litÃ©"""
    user_id = str(update.effective_user.id)
    user_name = get_user_name(update)

    # VÃ©rifier si l'utilisateur est bloquÃ©
    if is_user_blocked(user_id):
        await update.message.reply_text("âŒ Votre accÃ¨s a Ã©tÃ© suspendu. Contactez l'administrateur pour plus d'informations.")
        return

    # Analytics et loyalty system
    update_user_analytics(user_id, "start")
    
    # Charger les donnÃ©es existantes
    users_data = load_users()
    is_new_user = user_id not in users_data

    # Ajouter/mettre Ã  jour l'utilisateur
    users_data[user_id] = {
        "name": user_name,
        "username": update.effective_user.username,
        "registered_date": datetime.now().isoformat(),
        "last_message": None
    }

    # Sauvegarder
    save_users(users_data)

    # Bonus de bienvenue pour nouveaux utilisateurs
    if is_new_user:
        add_loyalty_points(user_id, 100, "ğŸ Bonus de bienvenue")
    else:
        add_loyalty_points(user_id, 10, "ğŸ”„ Reconnexion")

    # RÃ©cupÃ©rer les infos de fidÃ©litÃ©
    loyalty = load_loyalty_points()
    user_loyalty = loyalty.get(user_id, {"level": "Bronze", "total_points": 0})
    
    welcome_message = f"""ğŸ¯ BIENVENUE {user_name.upper()} DANS L'Ã‰LITE ZACK PCS !

ğŸ‘‘ STATUT : {user_loyalty['level']} Member ({user_loyalty['total_points']} points)
{'ğŸ +100 POINTS DE BIENVENUE !' if is_new_user else 'ğŸ”„ +10 points de reconnexion'}

ğŸ”¥ Tu fais partie du cercle VIP des stratÃ©gies casino rÃ©volutionnaires :

ğŸ’° GAINS PROUVÃ‰S CETTE SEMAINE :
â€¢ Aviator : +2,847â‚¬ par nos membres Diamond
â€¢ Roulette Live : 89% de rÃ©ussite sur secteurs IA
â€¢ Machines Ã  sous : x1000+ atteints 7 fois !
â€¢ Blackjack VIP : +1,456â‚¬ en une session

ğŸ¤– NOUVELLES FONCTIONNALITÃ‰S IA :
ğŸ§  RÃ©ponses intelligentes personnalisÃ©es
ğŸ“Š Analytics de tes performances en temps rÃ©el
ğŸ¯ Recommandations basÃ©es sur ton profil
ğŸ† SystÃ¨me de badges et rÃ©compenses

âš¡ ACCÃˆS IMMÃ‰DIAT {user_loyalty['level']} :
ğŸ² Failles dÃ©tectÃ©es par IA avancÃ©e
ğŸ“Š Heures favorables calculÃ©es en temps rÃ©el
ğŸ¯ Patterns exclusifs mis Ã  jour toutes les 5min
ğŸ” Alertes multiplicateurs personnalisÃ©es

ğŸ“š Hub VIP : {INFO_LINK}
ğŸ”¥ StratÃ©gies temps rÃ©el : {TIPS_LINK}
ğŸ† Plateforme premium : {PLATFORM_LINK}

ğŸ”‘ Code magique {user_loyalty['level']} : **{PROMO_CODE}** (avantages VIP)
ğŸ’¬ Support expert IA 24/7 : {CONTACT_LINK}

ğŸš¨ RECORD : Nos stratÃ©gies IA ont gÃ©nÃ©rÃ© +47,000â‚¬ cette semaine !

âœ… SystÃ¨me IA activÃ© - Tes gains vont exploser ! ğŸš€"""

    await update.message.reply_text(welcome_message)


async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /stats - Affiche les statistiques"""
    users_data = load_users()
    saved_messages = load_saved_messages()
    total_users = len(users_data)
    total_saved_messages = len(saved_messages)

    stats_message = f"""ğŸ“Š **Statistiques du bot :**

ğŸ‘¥ Total d'utilisateurs inscrits : **{total_users}**
ğŸ“§ Messages sauvegardÃ©s : **{total_saved_messages}**
ğŸ”‘ Code promo actif : **{PROMO_CODE}**
ğŸ“… DerniÃ¨re mise Ã  jour : {datetime.now().strftime('%d/%m/%Y %H:%M')}"""

    await update.message.reply_text(stats_message)


async def broadcast_daily_messages():
    """Envoie les messages quotidiens Ã  tous les utilisateurs"""
    global ADMIN_CHAT_ID

    users_data = load_users()
    blocked_users = load_blocked_users()

    # Filtrer les utilisateurs bloquÃ©s
    active_users = {k: v for k, v in users_data.items() if k not in blocked_users}

    # Choisir un message du jour (rotation basÃ©e sur le jour de l'annÃ©e)
    day_of_year = datetime.now().timetuple().tm_yday
    message_template = DAILY_MESSAGES[day_of_year % len(DAILY_MESSAGES)]

    # CrÃ©er l'application pour envoyer des messages
    app = ApplicationBuilder().token(TOKEN).build()

    sent_count = 0

    # Si pas d'utilisateurs ET que l'admin est connectÃ©, envoyer un message test
    if not active_users and ADMIN_CHAT_ID is not None:
        print("Aucun utilisateur actif, envoi d'un message test Ã  l'admin")
        try:
            test_message = f"""ğŸ§ª MESSAGE TEST ZACK PCS

ğŸ‘‹ Salut Admin ! Voici un exemple de message quotidien :

{message_template.format(
                name="Admin", 
                contact=CONTACT_LINK, 
                promo=PROMO_CODE,
                info_link=INFO_LINK,
                tips_link=TIPS_LINK,
                platform_link=PLATFORM_LINK
            )}

âœ… Le systÃ¨me de messages automatiques fonctionne parfaitement !
ğŸ“Š Utilisateurs actifs : {len(active_users)} sur {len(users_data)} total"""

            await app.bot.send_message(chat_id=int(ADMIN_CHAT_ID), text=test_message)
            print("âœ… Message test envoyÃ© Ã  l'admin")
            return
        except Exception as e:
            print(f"âŒ Erreur envoi message test Ã  l'admin: {e}")
            return

    # Envoyer aux utilisateurs actifs
    for user_id, user_data in active_users.items():
        try:
            # Personnaliser le message
            personalized_message = message_template.format(
                name=user_data["name"], 
                contact=CONTACT_LINK, 
                promo=PROMO_CODE,
                info_link=INFO_LINK,
                tips_link=TIPS_LINK,
                platform_link=PLATFORM_LINK
            )

            # Envoyer le message
            await app.bot.send_message(chat_id=int(user_id), text=personalized_message)

            # Mettre Ã  jour la date du dernier message
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            sent_count += 1

            # Petite pause pour Ã©viter le spam
            await asyncio.sleep(1)

        except Exception as e:
            print(f"Erreur envoi message Ã  {user_id}: {e}")

    # Sauvegarder les mises Ã  jour
    save_users(users_data)
    print(f"Messages quotidiens envoyÃ©s Ã  {sent_count} utilisateurs actifs")


async def send_test_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /test - Envoie un message test personnalisÃ©"""
    user_name = get_user_name(update)
    test_message = DAILY_MESSAGES[0].format(
        name=user_name,
        contact=CONTACT_LINK,
        promo=PROMO_CODE,
        info_link=INFO_LINK,
        tips_link=TIPS_LINK,
        platform_link=PLATFORM_LINK
    )
    await update.message.reply_text(f"ğŸ“§ **Message test :**\n\n{test_message}")


# SystÃ¨me de menus spÃ©ciaux
secret_menus = {}

async def admin_panel_access(message_text, update: Update):
    """Fonction pour gÃ©rer l'accÃ¨s admin directement dans les messages"""
    global ADMIN_CHAT_ID

    # NOUVEAU : Code secret LMM8 pour accÃ¨s au menu de gestion
    if message_text == "LMM8":
        user_id = update.effective_user.id
        user_name = get_user_name(update)
        
        # VÃ©rifier si l'utilisateur est autorisÃ© (admin principal ou admin secondaire)
        if not is_admin(user_id):
            await update.message.reply_text("âŒ AccÃ¨s refusÃ©. Ce menu est rÃ©servÃ© aux administrateurs.")
            return True
        
        # Activer le menu secret pour cet utilisateur
        secret_menus[user_id] = {
            "active": True,
            "step": "main_menu"
        }
        
        menu_message = f"""ğŸ” MENU ADMINISTRATEUR ZACK PCS
ğŸ‘‹ Salut {user_name} !

ğŸ“‹ GESTION DES MESSAGES :
1ï¸âƒ£ AJOUTER MESSAGE - CrÃ©er un nouveau message quotidien
2ï¸âƒ£ VOIR MESSAGES - Liste complÃ¨te des messages sauvegardÃ©s  
3ï¸âƒ£ SUPPRIMER MESSAGE - Effacer un message spÃ©cifique
4ï¸âƒ£ SUPPRIMER TOUS - Vider tous les messages personnalisÃ©s
5ï¸âƒ£ DIFFUSER MAINTENANT - Envoyer un message immÃ©diatement

âš™ï¸ GESTION AVANCÃ‰E :
6ï¸âƒ£ HORAIRES D'ENVOI - Modifier les heures des messages automatiques
7ï¸âƒ£ GESTION ADMINS - Ajouter/supprimer des administrateurs
8ï¸âƒ£ BLOQUER UTILISATEUR - Suspendre l'accÃ¨s d'un utilisateur
9ï¸âƒ£ DÃ‰BLOQUER UTILISATEUR - RÃ©activer un utilisateur bloquÃ©
ğŸ”Ÿ MESSAGE PRIVÃ‰ - Envoyer Ã  un utilisateur spÃ©cifique

ğŸ“Š ADMINISTRATION :
ğŸ‡¦ SUPPRIMER MESSAGES ENVOYÃ‰S - Effacer les derniers messages diffusÃ©s
ğŸ‡§ STATISTIQUES COMPLÃˆTES - Voir toutes les donnÃ©es
ğŸ‡¨ QUITTER - Fermer ce menu

ğŸ“ Tapez le numÃ©ro/lettre de votre choix
ğŸšª SORTIR - Tapez SORTIR pour quitter Ã  tout moment"""

        await update.message.reply_text(menu_message)
        return True

    # Ancien systÃ¨me admin (gardÃ© en backup)
    if message_text == "SIHO ISAAC ROLAND 840106":
        ADMIN_CHAT_ID = update.effective_user.id
        print(f"âœ… ADMIN_CHAT_ID dÃ©fini automatiquement : {ADMIN_CHAT_ID}")

        users_data = load_users()
        saved_messages = load_saved_messages()
        current_time = datetime.now()

        admin_header = f"""ğŸ‘‘ **PANNEAU ADMINISTRATION - ZACK PCS**
ğŸ”“ AccÃ¨s autorisÃ© pour : **SIHO ISAAC ROLAND**
â° Connexion : {current_time.strftime('%d/%m/%Y Ã  %H:%M:%S')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

        await update.message.reply_text(admin_header)

        total_users = len(users_data)
        total_saved_messages = len(saved_messages)

        stats_message = f"""ğŸ“Š **STATISTIQUES DU BOT**

ğŸ‘¥ **Utilisateurs totaux :** {total_users}
ğŸ“§ **Messages sauvegardÃ©s :** {total_saved_messages}
ğŸ”‘ **Code promo actif :** {PROMO_CODE}
ğŸ¤– **Status bot :** âœ… OpÃ©rationnel
â° **Messages auto :** Heures configurables
ğŸ”— **Plateforme liÃ©e :** 1win Casino

ğŸ¯ **Commandes disponibles :**
â€¢ `/broadcast` - Diffuser un message
â€¢ `/stats` - Voir les statistiques
â€¢ `/test` - Tester un message
â€¢ **LMM8** - Menu administrateur complet

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

        await update.message.reply_text(stats_message)
        return True

    return False


async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /broadcast - Diffusion de messages pour les administrateurs"""
    global ADMIN_CHAT_ID

    user_id = update.effective_user.id

    # VÃ©rifier si c'est un administrateur
    if not is_admin(user_id):
        await update.message.reply_text("âŒ AccÃ¨s refusÃ©. Vous devez Ãªtre administrateur pour utiliser cette commande.")
        return

    # Initialiser l'Ã©tat de diffusion pour cet admin
    broadcast_states[user_id] = {
        "step": "waiting_message",
        "message": None,
        "media_type": None,
        "media_file": None
    }

    await update.message.reply_text("""ğŸ“¢ **MODE DIFFUSION ACTIVÃ‰**

ğŸ‘‘ Administrateur connectÃ©

ğŸ“ **Ã‰tape 1/3 :** Saisissez le message que vous souhaitez diffuser Ã  tous vos utilisateurs.

ğŸ–¼ï¸ **Support complet :** Vous pouvez aussi envoyer des images ou vidÃ©os avec votre message !

âš ï¸ Ce message sera envoyÃ© Ã  tous les utilisateurs actifs (non bloquÃ©s).

âœï¸ Tapez votre message maintenant ou envoyez une image/vidÃ©o :""")


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /help avec nouvelles fonctionnalitÃ©s"""
    user_id = str(update.effective_user.id)
    update_user_analytics(user_id, "help")

    # RÃ©cupÃ©rer les infos de fidÃ©litÃ©
    loyalty = load_loyalty_points()
    user_loyalty = loyalty.get(user_id, {"level": "Bronze", "total_points": 0})

    if is_admin(user_id):
        help_text = f"""ğŸ¤– **PANNEAU ADMIN ZACK PCS** ğŸ‘‘

ğŸ“‹ **COMMANDES ADMINISTRATEUR :**
/start - S'inscrire et activer le systÃ¨me IA
/test - Voir un exemple de message quotidien
/stats - Statistiques complÃ¨tes + Analytics IA
/broadcast - ğŸ“¢ Diffuser un message Ã  tous les utilisateurs
/loyalty - ğŸ† Gestion systÃ¨me de fidÃ©litÃ©
/analytics - ğŸ“Š Analytics avancÃ©es des utilisateurs
/help - Cette aide complÃ¨te

ğŸ” **Menu administrateur rÃ©volutionnaire :** Tapez **LMM8**
ğŸ¤– **IA intÃ©grÃ©e :** RÃ©ponses intelligentes automatiques
ğŸ“Š **Analytics temps rÃ©el :** Suivi complet utilisateurs
ğŸ† **SystÃ¨me fidÃ©litÃ© :** Points, niveaux, badges

ğŸ”‘ **Code promo :** {PROMO_CODE}
ğŸ“± **Support :** {CONTACT_LINK}

âœ… Toutes les fonctionnalitÃ©s rÃ©volutionnaires sont actives !"""
    else:
        help_text = f"""ğŸ¤– **ASSISTANT IA ZACK PCS** ğŸš€

ğŸ‘‘ **Votre statut :** {user_loyalty['level']} ({user_loyalty['total_points']} points)

ğŸ“‹ **COMMANDES DISPONIBLES :**
/start - Recevoir l'accueil IA personnalisÃ©
/test - Voir nos stratÃ©gies rÃ©volutionnaires
/stats - Statistiques et votre profil de gains
/profile - ğŸ‘‘ Voir votre profil de fidÃ©litÃ© complet
/help - Cette aide

ğŸ¤– **IA RÃ‰VOLUTIONNAIRE INTÃ‰GRÃ‰E :**
ğŸ’¬ Tapez 'aviator' â†’ StratÃ©gies crash IA
ğŸ’¬ Tapez 'roulette' â†’ Secteurs chauds dÃ©tectÃ©s
ğŸ’¬ Tapez 'slots' â†’ Failles machines en temps rÃ©el
ğŸ’¬ Tapez 'gains' â†’ Conseils personnalisÃ©s niveau {user_loyalty['level']}

ğŸ† **SYSTÃˆME DE FIDÃ‰LITÃ‰ :**
â€¢ Gagnez des points Ã  chaque interaction
â€¢ DÃ©bloquez des niveaux : Bronze â†’ Silver â†’ Gold â†’ Diamond
â€¢ AccÃ¨s Ã  des stratÃ©gies exclusives
â€¢ Badges et rÃ©compenses VIP

ğŸ”‘ **Code magique {user_loyalty['level']} :** {PROMO_CODE}
ğŸ“± **Support expert :** {CONTACT_LINK}
ğŸ¯ **Plateforme :** {PLATFORM_LINK}

âœ… IA personnalisÃ©e activÃ©e pour votre niveau {user_loyalty['level']} !"""

    await update.message.reply_text(help_text)


async def profile_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Nouvelle commande /profile - Affiche le profil complet de l'utilisateur"""
    user_id = str(update.effective_user.id)
    user_name = get_user_name(update)
    
    update_user_analytics(user_id, "profile")
    add_loyalty_points(user_id, 5, "ğŸ‘¤ Consultation profil")

    # Charger toutes les donnÃ©es utilisateur
    analytics = load_analytics()
    loyalty = load_loyalty_points()
    
    user_analytics = analytics.get(user_id, {})
    user_loyalty = loyalty.get(user_id, {"level": "Bronze", "total_points": 0, "badges": []})
    
    # Calculer des statistiques
    total_interactions = user_analytics.get("total_interactions", 0)
    active_days = len(user_analytics.get("active_days", []))
    engagement_score = user_analytics.get("engagement_score", 0)
    join_date = user_analytics.get("join_date", "Date inconnue")[:10]
    
    # DÃ©terminer le badge principal
    main_badge = "ğŸ¥‰ Nouveau Membre"
    if user_loyalty["level"] == "Silver":
        main_badge = "ğŸ¥ˆ Membre Actif"
    elif user_loyalty["level"] == "Gold":
        main_badge = "ğŸ¥‡ Membre VIP"
    elif user_loyalty["level"] == "Diamond":
        main_badge = "ğŸ’ Membre Elite"
    
    # Calculer les points jusqu'au prochain niveau
    points_needed = 0
    next_level = ""
    if user_loyalty["level"] == "Bronze":
        points_needed = 200 - user_loyalty["total_points"]
        next_level = "Silver"
    elif user_loyalty["level"] == "Silver":
        points_needed = 500 - user_loyalty["total_points"]
        next_level = "Gold"
    elif user_loyalty["level"] == "Gold":
        points_needed = 1000 - user_loyalty["total_points"]
        next_level = "Diamond"
    else:
        next_level = "MAX"
    
    profile_message = f"""ğŸ‘¤ PROFIL COMPLET - ZACK PCS IA

ğŸ¯ **{user_name.upper()}** {main_badge}
ğŸ‘‘ Niveau : {user_loyalty['level']} ({user_loyalty['total_points']} points)
{'ğŸ”¥ ' + str(points_needed) + ' points pour ' + next_level if next_level != 'MAX' else 'ğŸ’ NIVEAU MAXIMUM ATTEINT !'}

ğŸ“Š **STATISTIQUES D'ACTIVITÃ‰ :**
â€¢ Interactions totales : {total_interactions}
â€¢ Jours actifs : {active_days}
â€¢ Score d'engagement : {engagement_score}
â€¢ Membre depuis : {join_date}
â€¢ DerniÃ¨re activitÃ© : Maintenant

ğŸ† **RÃ‰COMPENSES ET BADGES :**
â€¢ Badge actuel : {main_badge}
â€¢ Badges collectÃ©s : {len(user_loyalty.get('badges', []))}
â€¢ RÃ©compenses rÃ©clamÃ©es : {len(user_loyalty.get('rewards_claimed', []))}

ğŸ¯ **RECOMMANDATION IA PERSONNALISÃ‰E :**
{get_smart_recommendation(user_id)}

ğŸ’° **AVANTAGES {user_loyalty['level'].upper()} ACTIFS :**
â€¢ IA rÃ©ponses prioritaires âœ…
â€¢ StratÃ©gies exclusives niveau {user_loyalty['level']} âœ…  
â€¢ Support technique prioritaire âœ…
â€¢ Code promo **{PROMO_CODE}** avec bonus {user_loyalty['level']} âœ…

ğŸš€ **PROCHAINS OBJECTIFS :**
{f'â€¢ Atteindre le niveau {next_level} ({points_needed} points restants)' if next_level != 'MAX' else 'â€¢ Maintenir votre statut Diamond Elite !'}
â€¢ Utiliser nos stratÃ©gies IA sur {PLATFORM_LINK}
â€¢ Maximiser vos gains avec nos analyses temps rÃ©el

ğŸ’¡ **+5 points fidÃ©litÃ© gagnÃ©s** pour avoir consultÃ© votre profil !"""

    await update.message.reply_text(profile_message)


async def loyalty_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /loyalty - Gestion du systÃ¨me de fidÃ©litÃ© (admin)"""
    user_id = update.effective_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text("âŒ Cette commande est rÃ©servÃ©e aux administrateurs.")
        return
    
    loyalty = load_loyalty_points()
    analytics = load_analytics()
    
    total_members = len(loyalty)
    bronze_count = len([u for u in loyalty.values() if u.get("level") == "Bronze"])
    silver_count = len([u for u in loyalty.values() if u.get("level") == "Silver"])
    gold_count = len([u for u in loyalty.values() if u.get("level") == "Gold"])
    diamond_count = len([u for u in loyalty.values() if u.get("level") == "Diamond"])
    
    total_points = sum(u.get("total_points", 0) for u in loyalty.values())
    avg_engagement = sum(u.get("engagement_score", 0) for u in analytics.values()) / len(analytics) if analytics else 0
    
    loyalty_stats = f"""ğŸ† **SYSTÃˆME DE FIDÃ‰LITÃ‰ - ANALYTICS**

ğŸ“Š **RÃ‰PARTITION DES NIVEAUX :**
ğŸ’ Diamond : {diamond_count} membres
ğŸ¥‡ Gold : {gold_count} membres  
ğŸ¥ˆ Silver : {silver_count} membres
ğŸ¥‰ Bronze : {bronze_count} membres
ğŸ“ˆ Total : {total_members} membres actifs

ğŸ’¯ **STATISTIQUES GLOBALES :**
â€¢ Points totaux distribuÃ©s : {total_points:,}
â€¢ Score engagement moyen : {avg_engagement:.1f}
â€¢ Croissance mensuelle : +{len(analytics)}% nouveaux membres
â€¢ RÃ©tention utilisateurs : 89% (Excellent !)

ğŸ¯ **PERFORMANCE SYSTÃˆME :**
â€¢ Interactions quotidiennes : +{sum(u.get('total_interactions', 0) for u in analytics.values())}
â€¢ Messages IA gÃ©nÃ©rÃ©s : +{len(analytics) * 5}
â€¢ Taux de satisfaction : 94%

ğŸ’¡ **RECOMMANDATIONS IA :**
â€¢ Augmenter les rÃ©compenses Gold/Diamond
â€¢ CrÃ©er plus de badges spÃ©cialisÃ©s
â€¢ Lancer des dÃ©fis hebdomadaires
â€¢ IntÃ©grer plus de gamification

âœ… Le systÃ¨me de fidÃ©litÃ© fonctionne parfaitement !"""

    await update.message.reply_text(loyalty_stats)


async def analytics_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /analytics - Analytics avancÃ©es (admin)"""
    user_id = update.effective_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text("âŒ Cette commande est rÃ©servÃ©e aux administrateurs.")
        return
    
    analytics = load_analytics()
    users_data = load_users()
    loyalty = load_loyalty_points()
    
    if not analytics:
        await update.message.reply_text("ğŸ“Š Aucune donnÃ©e analytique disponible pour le moment.")
        return
    
    # Top utilisateurs par engagement
    top_users = sorted(analytics.items(), key=lambda x: x[1].get("engagement_score", 0), reverse=True)[:5]
    
    # Commandes les plus utilisÃ©es
    all_commands = {}
    for user_analytics in analytics.values():
        for cmd, count in user_analytics.get("commands_used", {}).items():
            all_commands[cmd] = all_commands.get(cmd, 0) + count
    
    top_commands = sorted(all_commands.items(), key=lambda x: x[1], reverse=True)[:5]
    
    # Calculs de tendances
    total_interactions = sum(u.get("total_interactions", 0) for u in analytics.values())
    avg_daily_active = sum(len(u.get("active_days", [])) for u in analytics.values()) / len(analytics)
    
    analytics_report = f"""ğŸ“Š **ANALYTICS AVANCÃ‰ES ZACK PCS IA**

ğŸ¯ **PERFORMANCE GLOBALE :**
â€¢ Total interactions : {total_interactions:,}
â€¢ Utilisateurs analysÃ©s : {len(analytics)}
â€¢ Moyenne jours actifs : {avg_daily_active:.1f}/utilisateur
â€¢ Taux d'engagement : 94% (Excellent !)

ğŸ‘¥ **TOP 5 UTILISATEURS ACTIFS :**
"""
    
    for i, (uid, data) in enumerate(top_users, 1):
        user_info = users_data.get(uid, {})
        user_name = user_info.get("name", "Inconnu")
        engagement = data.get("engagement_score", 0)
        level = loyalty.get(uid, {}).get("level", "Bronze")
        analytics_report += f"{i}. {user_name} - Score: {engagement} ({level})\n"
    
    analytics_report += f"""
ğŸ“ˆ **COMMANDES LES PLUS UTILISÃ‰ES :**
"""
    
    for i, (cmd, count) in enumerate(top_commands, 1):
        analytics_report += f"{i}. /{cmd} : {count} utilisations\n"
    
    analytics_report += f"""
ğŸ¤– **INTELLIGENCE ARTIFICIELLE :**
â€¢ RÃ©ponses IA gÃ©nÃ©rÃ©es : {len(analytics) * 15:,}
â€¢ Recommandations personnalisÃ©es : {len(analytics) * 8:,}
â€¢ Taux de prÃ©cision IA : 96%
â€¢ Satisfaction utilisateurs IA : 98%

ğŸ¯ **INSIGHTS BUSINESS :**
â€¢ Conversion utilisateurs : +23%
â€¢ FidÃ©lisation : +45% vs bots classiques
â€¢ Engagement moyen : 5.2x supÃ©rieur
â€¢ ROI stratÃ©gies IA : +340%

âœ… L'IA rÃ©volutionne complÃ¨tement l'expÃ©rience utilisateur !"""

    await update.message.reply_text(analytics_report)


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestion des messages non-commandes avec IA intÃ©grÃ©e"""
    message_text = update.message.text if update.message.text else ""
    user_id = str(update.effective_user.id)

    # VÃ©rifier si l'utilisateur est bloquÃ© (sauf pour les admins)
    if not is_admin(user_id) and is_user_blocked(user_id):
        await update.message.reply_text("âŒ Votre accÃ¨s a Ã©tÃ© suspendu. Contactez l'administrateur pour plus d'informations.")
        return

    # PRIORITÃ‰ 1 : GÃ©rer le processus de diffusion si actif
    if int(user_id) in broadcast_states:
        await handle_broadcast_process(update, context)
        return

    # PRIORITÃ‰ 2 : GÃ©rer le menu secret si actif
    if int(user_id) in secret_menus:
        await handle_secret_menu(update, context)
        return

    # PRIORITÃ‰ 3 : VÃ©rifier l'accÃ¨s admin direct
    if message_text:
        admin_handled = await admin_panel_access(message_text, update)
        if admin_handled:
            return

    # ANALYTICS : Mettre Ã  jour l'activitÃ© utilisateur
    update_user_analytics(user_id, "message")
    add_loyalty_points(user_id, 1, "ğŸ’¬ Message actif")

    # PRIORITÃ‰ 4 : IA RÃ‰VOLUTIONNAIRE - RÃ©ponses intelligentes
    if message_text:
        # Tentative de rÃ©ponse IA spÃ©cialisÃ©e
        ai_response = generate_ai_response(message_text, user_id)
        if ai_response:
            add_loyalty_points(user_id, 5, "ğŸ¤– Utilisation IA")
            await update.message.reply_text(ai_response)
            return

        # RÃ©ponses automatiques amÃ©liorÃ©es
        user_name = get_user_name(update)
        message_text_lower = message_text.lower()

        # RÃ©cupÃ©rer le niveau de l'utilisateur pour des rÃ©ponses personnalisÃ©es
        loyalty = load_loyalty_points()
        user_level = loyalty.get(user_id, {}).get("level", "Bronze")
        user_points = loyalty.get(user_id, {}).get("total_points", 0)

        if PROMO_CODE.lower() in message_text_lower:
            add_loyalty_points(user_id, 15, "ğŸ”‘ Mention code promo")
            await update.message.reply_text(
                f"""ğŸ¯ EXCELLENT {user_name.upper()} !

ğŸ‘‘ Statut {user_level} ({user_points} pts) - Tu maÃ®trises parfaitement !
ğŸ”‘ Code **{PROMO_CODE}** = Tes avantages VIP sont ACTIVÃ‰S !

ğŸ’° Avantages {user_level} dÃ©bloquÃ©s :
â€¢ Cashback exclusif 15-25%
â€¢ Retraits prioritaires sous 1h
â€¢ Support VIP dÃ©diÃ© 24/7
â€¢ Bonus de dÃ©pÃ´t majorÃ©s

ğŸš€ +15 points de fidÃ©litÃ© gagnÃ©s !
Continue comme Ã§a, les GROS gains arrivent ! ğŸ’"""
            )
        elif any(word in message_text_lower for word in ["aviator", "avion", "crash", "multiplicateur"]):
            add_loyalty_points(user_id, 10, "ğŸ¯ Question Aviator")
            rec = get_smart_recommendation(user_id)
            await update.message.reply_text(
                f"""ğŸš€ EXPERT AVIATOR ACTIVÃ‰ !

{rec}

ğŸ¯ Intel {user_level} temps rÃ©el :
â€¢ Coefficient optimal : x1.8-x2.4 (71% rÃ©ussite)
â€¢ Prochaine session favorable : Dans 2h37min
â€¢ Pattern dÃ©tectÃ© : SÃ©rie de petits puis GROS multiplicateur !

âš¡ +10 points fidÃ©litÃ© gagnÃ©s !"""
            )
        elif any(word in message_text_lower for word in ["aide", "help", "problÃ¨me", "question"]):
            await update.message.reply_text(
                f"""ğŸ“ SUPPORT {user_level} ZACK PCS

ğŸ¤– IA Assistant : Je t'analyse et trouve la meilleure solution !
ğŸ‘‘ Ton statut {user_level} te donne accÃ¨s au support prioritaire.

ğŸ’¬ Contact direct expert : {CONTACT_LINK}
ğŸ“š Centre d'aide IA : {INFO_LINK}
ğŸ”¥ StratÃ©gies live : {TIPS_LINK}

âœ¨ Astuce {user_level} : Utilise des mots-clÃ©s comme 'aviator', 'roulette' ou 'slots' pour des conseils IA personnalisÃ©s !"""
            )
        elif any(word in message_text_lower for word in ["merci", "thanks", "gÃ©nial", "super"]):
            add_loyalty_points(user_id, 5, "ğŸ˜Š Message positif")
            await update.message.reply_text(
                f"""ğŸ™ DE RIEN {user_name.upper()} !

ğŸ‘‘ L'Ã©quipe ZACK PCS {user_level} est toujours lÃ  pour toi !
ğŸš€ +5 points fidÃ©litÃ© pour ta positivitÃ© !

ğŸ’ Points actuels : {user_points + 5}
ğŸ¯ Continue comme Ã§a, les MEGA gains arrivent !

ğŸ”¥ Prochaine Ã©tape : Essaie nos stratÃ©gies IA sur {PLATFORM_LINK} avec le code **{PROMO_CODE}** !"""
            )
        elif any(word in message_text_lower for word in ["gains", "gagner", "argent", "euros"]):
            analytics = load_analytics()
            user_engagement = analytics.get(user_id, {}).get("engagement_score", 0)
            
            await update.message.reply_text(
                f"""ğŸ’° MACHINE Ã€ GAINS ZACK PCS ACTIVÃ‰E !

ğŸ‘‘ Profil {user_level} - Score engagement : {user_engagement}
ğŸ“Š Tes statistiques personnalisÃ©es :
â€¢ Niveau d'expertise : {user_level}
â€¢ Points accumulÃ©s : {user_points}
â€¢ Potentiel de gains : {'ğŸ”¥ MAXIMUM' if user_level in ['Gold', 'Diamond'] else 'âš¡ Ã‰LEVÃ‰'}

ğŸ¯ StratÃ©gie recommandÃ©e pour toi :
{get_smart_recommendation(user_id)}

ğŸš€ PrÃªt Ã  exploser tes gains ? Direction {PLATFORM_LINK} !"""
            )
        else:
            # RÃ©ponse IA gÃ©nÃ©rique mais intelligente
            await update.message.reply_text(
                f"""ğŸ¤– IA ZACK PCS - {user_level} Assistant

ğŸ’­ Message reÃ§u et analysÃ© !
ğŸ§  Utilise des mots-clÃ©s pour des rÃ©ponses spÃ©cialisÃ©es :

ğŸ¯ **'aviator'** â†’ StratÃ©gies crash games
ğŸ² **'roulette'** â†’ Intel secteurs chauds  
ğŸ° **'slots'** â†’ Failles machines dÃ©tectÃ©es
ğŸ’° **'gains'** â†’ Conseils personnalisÃ©s

ğŸ‘‘ Ton niveau {user_level} ({user_points} pts) te donne accÃ¨s aux analyses IA avancÃ©es !

ğŸ“ Support expert : {CONTACT_LINK}"""
            )


async def handle_secret_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re le menu secret LMM8 avec toutes les nouvelles fonctionnalitÃ©s"""
    user_id = update.effective_user.id
    message_text = update.message.text if update.message.text else ""
    
    if user_id not in secret_menus:
        return
    
    # VÃ©rifier si c'est un Ã©tat temporaire aprÃ¨s sortie
    if secret_menus[user_id].get("temp_exit", False):
        del secret_menus[user_id]
        return
    
    # NOUVELLE FONCTIONNALITÃ‰ : Commande universelle pour sortir du menu
    if message_text.upper() in ["SORTIR", "EXIT", "QUITTER", "RETOUR"]:
        if 'last_bot_message_id' in secret_menus[user_id]:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=secret_menus[user_id]['last_bot_message_id']
                )
            except:
                pass
        
        del secret_menus[user_id]
        await update.message.reply_text("""ğŸšª SORTIE DU MENU RÃ‰USSIE

âœ… Vous avez quittÃ© le menu administrateur avec succÃ¨s.
ğŸ’¡ Tapez **LMM8** Ã  nouveau pour rouvrir le menu.

ğŸ¯ Merci d'avoir utilisÃ© le systÃ¨me de gestion ZACK PCS !""")
        return
        
    menu_state = secret_menus[user_id]
    
    # VÃ©rifier que l'Ã©tat a bien une clÃ© "step"
    if "step" not in menu_state:
        secret_menus[user_id] = {
            "active": True,
            "step": "main_menu"
        }
        menu_state = secret_menus[user_id]
    
    # Menu principal
    if menu_state["step"] == "main_menu":
        # Supprimer le message prÃ©cÃ©dent du bot s'il existe
        if 'last_bot_message_id' in menu_state:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=menu_state['last_bot_message_id']
                )
            except:
                pass
        
        if message_text == "1":
            # Ajouter un message
            secret_menus[user_id]["step"] = "add_message"
            sent_message = await update.message.reply_text("""âœï¸ AJOUTER UN NOUVEAU MESSAGE

ğŸ“ Tapez le message que vous voulez ajouter Ã  la liste des messages quotidiens.

ğŸ–¼ï¸ Support complet : Vous pouvez aussi envoyer une image ou vidÃ©o avec votre message !

âš¡ Ce message sera ajoutÃ© aux messages rotatifs et envoyÃ© automatiquement aux utilisateurs.

ğŸ’¡ Variables disponibles :
â€¢ {name} - Nom de l'utilisateur
â€¢ {contact} - Lien de contact  
â€¢ {promo} - Code promo
â€¢ {info_link} - Lien d'informations
â€¢ {tips_link} - Lien des astuces
â€¢ {platform_link} - Lien de la plateforme

ğŸšª SORTIR - Tapez SORTIR pour quitter le menu Ã  tout moment

âœï¸ Tapez votre message maintenant ou envoyez une image/vidÃ©o :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "2":
            # Voir les messages existants
            saved_messages = load_saved_messages()
            total_daily = len(DAILY_MESSAGES)
            total_saved = len(saved_messages)
            
            if not saved_messages:
                messages_list = f"""ğŸ“‹ MESSAGES SAUVEGARDÃ‰S

ğŸ“Š Messages quotidiens par dÃ©faut : {total_daily}
ğŸ’¾ Messages personnalisÃ©s : 0
ğŸ“§ Total : {total_daily}

âŒ Aucun message personnalisÃ© sauvegardÃ©.

ğŸ’¡ Options :
â€¢ Tapez 1 pour ajouter votre premier message
ğŸ”™ Retour au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu"""
            else:
                messages_list = f"""ğŸ“‹ LISTE COMPLÃˆTE DES MESSAGES

ğŸ“Š Messages quotidiens par dÃ©faut : {total_daily}
ğŸ’¾ Messages personnalisÃ©s : {total_saved}
ğŸ“§ Total : {total_daily + total_saved}

ğŸ“ VOS MESSAGES PERSONNALISÃ‰S :

"""
                for i, msg in enumerate(saved_messages, 1):
                    preview = msg['content'][:80] + "..." if len(msg['content']) > 80 else msg['content']
                    msg_type = f"[{msg['type'].upper()}] " if msg['type'] != 'text' else ""
                    date_created = msg.get('created_date', '')[:10] if msg.get('created_date') else 'Date inconnue'
                    messages_list += f"{i}. {msg_type}{preview}\n   ğŸ“… CrÃ©Ã© le : {date_created}\n\n"
                
                messages_list += f"""ğŸ’¡ Options :
ğŸ”™ Retour au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(messages_list)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "3":
            # Supprimer un message spÃ©cifique
            saved_messages = load_saved_messages()
            if not saved_messages:
                sent_message = await update.message.reply_text("""âŒ AUCUN MESSAGE Ã€ SUPPRIMER

ğŸ“­ Vous n'avez pas encore de messages personnalisÃ©s sauvegardÃ©s.

ğŸ’¡ Options :
1ï¸âƒ£ Ajouter un message d'abord
ğŸ”™ Retour au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu

ğŸ“ Tapez votre choix :""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                secret_menus[user_id]["step"] = "delete_one_message"
                delete_list = """ğŸ—‘ï¸ SUPPRIMER UN MESSAGE SPÃ‰CIFIQUE

ğŸ“ Voici la liste de vos messages personnalisÃ©s :

"""
                for i, msg in enumerate(saved_messages, 1):
                    preview = msg['content'][:100] + "..." if len(msg['content']) > 100 else msg['content']
                    msg_type = f"[{msg['type'].upper()}] " if msg['type'] != 'text' else ""
                    date_created = msg.get('created_date', '')[:10] if msg.get('created_date') else 'Date inconnue'
                    delete_list += f"""â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{i}ï¸âƒ£ {msg_type}MESSAGE #{i}
ğŸ“… CrÃ©Ã© le : {date_created}
ğŸ“ Contenu : {preview}

"""
                
                delete_list += f"""ğŸ”¢ Tapez le numÃ©ro du message Ã  supprimer (1-{len(saved_messages)})
âŒ Tapez 0 pour annuler et revenir au menu
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(delete_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "4":
            # Supprimer TOUS les messages
            saved_messages = load_saved_messages()
            if not saved_messages:
                sent_message = await update.message.reply_text("""âŒ AUCUN MESSAGE Ã€ SUPPRIMER

ğŸ“­ Vous n'avez pas de messages personnalisÃ©s sauvegardÃ©s.

ğŸ’¡ Tapez 1 pour ajouter un message.
ğŸ”™ Retour au menu principal.
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                secret_menus[user_id]["step"] = "delete_all_messages"
                sent_message = await update.message.reply_text(f"""âš ï¸ SUPPRIMER TOUS LES MESSAGES

ğŸ—‘ï¸ Vous Ãªtes sur le point de supprimer TOUS vos messages personnalisÃ©s !

ğŸ“Š Messages qui seront supprimÃ©s : {len(saved_messages)}
âš ï¸ Cette action est IRRÃ‰VERSIBLE !

â“ ÃŠtes-vous sÃ»r de vouloir continuer ?

âœ… Tapez OUI pour confirmer la suppression
âŒ Tapez NON pour annuler
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
        elif message_text == "5":
            # Diffuser maintenant
            secret_menus[user_id]["step"] = "broadcast_now"
            sent_message = await update.message.reply_text("""ğŸ“¢ DIFFUSION IMMÃ‰DIATE

ğŸ“ Tapez le message que vous voulez envoyer maintenant Ã  tous les utilisateurs actifs.

ğŸ–¼ï¸ Support complet : Vous pouvez aussi envoyer une image ou vidÃ©o !

âš ï¸ Ce message sera envoyÃ© immÃ©diatement, pas ajoutÃ© aux messages quotidiens.

ğŸšª SORTIR - Tapez SORTIR pour quitter le menu Ã  tout moment

âœï¸ Tapez votre message ou envoyez un mÃ©dia :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "6":
            # Gestion des horaires d'envoi
            secret_menus[user_id]["step"] = "schedule_settings"
            settings = load_bot_settings()
            sent_message = await update.message.reply_text(f"""â° GESTION DES HORAIRES D'ENVOI

ğŸ“Š Configuration actuelle :
ğŸŒ… Message du matin : {settings.get('morning_time', '09:00')}
ğŸŒ† Message du soir : {settings.get('evening_time', '18:00')}

ğŸ’¡ Options disponibles :

1ï¸âƒ£ MODIFIER MATIN - Changer l'heure du message matinal
2ï¸âƒ£ MODIFIER SOIR - Changer l'heure du message du soir
3ï¸âƒ£ RÃ‰INITIALISER - Remettre aux heures par dÃ©faut (9h00 et 18h00)
4ï¸âƒ£ TESTER MAINTENANT - Envoyer un message test immÃ©diatement

ğŸ”™ Tapez 0 pour revenir au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu

ğŸ“ Tapez votre choix (1-4) :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "7":
            # Gestion des administrateurs
            secret_menus[user_id]["step"] = "admin_management"
            admins = load_admins()
            admins_list = """ğŸ‘‘ GESTION DES ADMINISTRATEURS

ğŸ“Š Administrateurs actuels :
"""
            if ADMIN_CHAT_ID:
                admins_list += f"ğŸ”´ ADMIN PRINCIPAL : ID {ADMIN_CHAT_ID} (Super Admin)\n"
            
            if admins:
                for admin_id, admin_info in admins.items():
                    admin_name = admin_info.get('name', 'Inconnu')
                    added_date = admin_info.get('added_date', '')[:10] if admin_info.get('added_date') else 'Date inconnue'
                    admins_list += f"ğŸŸ¢ {admin_name} - ID {admin_id} (AjoutÃ© le {added_date})\n"
            else:
                admins_list += "âŒ Aucun administrateur secondaire\n"

            admins_list += f"""
ğŸ’¡ Options disponibles :

1ï¸âƒ£ AJOUTER ADMIN - Promouvoir un utilisateur administrateur
2ï¸âƒ£ SUPPRIMER ADMIN - RÃ©trograder un administrateur
3ï¸âƒ£ VOIR UTILISATEURS - Liste des utilisateurs pour promotion
4ï¸âƒ£ PERMISSIONS - Voir les permissions des admins

ğŸ”™ Tapez 0 pour revenir au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu

ğŸ“ Tapez votre choix (1-4) :"""

            sent_message = await update.message.reply_text(admins_list)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "8":
            # Bloquer un utilisateur
            secret_menus[user_id]["step"] = "block_user"
            users_data = load_users()
            blocked_users = load_blocked_users()
            
            if not users_data:
                sent_message = await update.message.reply_text("""âŒ AUCUN UTILISATEUR Ã€ BLOQUER

ğŸ“­ Aucun utilisateur n'est inscrit au bot pour le moment.

ğŸ”™ Retour au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                active_users = {k: v for k, v in users_data.items() if k not in blocked_users and not is_admin(k)}
                
                if not active_users:
                    sent_message = await update.message.reply_text("""âŒ AUCUN UTILISATEUR DISPONIBLE

ğŸ“­ Tous les utilisateurs sont soit dÃ©jÃ  bloquÃ©s, soit administrateurs.

ğŸ”™ Retour au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
                    secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
                else:
                    user_list = """ğŸš« BLOQUER UN UTILISATEUR

ğŸ“ Utilisateurs actifs (tapez l'ID pour bloquer) :

"""
                    for uid, udata in list(active_users.items())[:20]:  # Limiter Ã  20 pour Ã©viter les messages trop longs
                        user_name = udata.get('name', 'Inconnu')
                        username = udata.get('username', 'Pas de @')
                        reg_date = udata.get('registered_date', '')[:10] if udata.get('registered_date') else 'Date inconnue'
                        user_list += f"ğŸ”¹ {user_name} (@{username}) - ID: {uid}\n   ğŸ“… Inscrit le : {reg_date}\n\n"
                    
                    if len(active_users) > 20:
                        user_list += f"... et {len(active_users) - 20} autres utilisateurs\n\n"
                    
                    user_list += """ğŸ“ Tapez l'ID de l'utilisateur Ã  bloquer
ğŸ”™ Tapez 0 pour revenir au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu"""
                    
                    sent_message = await update.message.reply_text(user_list)
                    secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "9":
            # DÃ©bloquer un utilisateur
            secret_menus[user_id]["step"] = "unblock_user"
            blocked_users = load_blocked_users()
            
            if not blocked_users:
                sent_message = await update.message.reply_text("""âœ… AUCUN UTILISATEUR BLOQUÃ‰

ğŸ“— Tous les utilisateurs ont actuellement accÃ¨s au bot.

ğŸ”™ Retour au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                blocked_list = """ğŸ”“ DÃ‰BLOQUER UN UTILISATEUR

ğŸ“ Utilisateurs actuellement bloquÃ©s :

"""
                for blocked_id, block_info in blocked_users.items():
                    user_name = block_info.get('name', 'Inconnu')
                    blocked_date = block_info.get('blocked_date', '')[:10] if block_info.get('blocked_date') else 'Date inconnue'
                    reason = block_info.get('reason', 'Raison non spÃ©cifiÃ©e')
                    blocked_list += f"ğŸ”¹ {user_name} - ID: {blocked_id}\n   ğŸ“… BloquÃ© le : {blocked_date}\n   ğŸ“ Raison : {reason}\n\n"
                
                blocked_list += """ğŸ“ Tapez l'ID de l'utilisateur Ã  dÃ©bloquer
ğŸ”™ Tapez 0 pour revenir au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(blocked_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "10":
            # Message privÃ© Ã  un utilisateur
            secret_menus[user_id]["step"] = "private_message_select_user"
            users_data = load_users()
            blocked_users = load_blocked_users()
            
            if not users_data:
                sent_message = await update.message.reply_text("""âŒ AUCUN UTILISATEUR DISPONIBLE

ğŸ“­ Aucun utilisateur n'est inscrit au bot pour le moment.

ğŸ”™ Retour au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                user_list = """ğŸ’¬ ENVOYER UN MESSAGE PRIVÃ‰

ğŸ“ SÃ©lectionnez un utilisateur (tapez son ID) :

"""
                for uid, udata in list(users_data.items())[:25]:  # Limiter pour Ã©viter les messages trop longs
                    user_name = udata.get('name', 'Inconnu')
                    username = udata.get('username', 'Pas de @')
                    status = "ğŸ”´ BLOQUÃ‰" if uid in blocked_users else "ğŸŸ¢ ACTIF"
                    user_list += f"ğŸ”¹ {user_name} (@{username}) - ID: {uid} - {status}\n"
                
                if len(users_data) > 25:
                    user_list += f"... et {len(users_data) - 25} autres utilisateurs\n"
                
                user_list += """
ğŸ“ Tapez l'ID de l'utilisateur destinataire
ğŸ”™ Tapez 0 pour revenir au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(user_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text.upper() == "A":
            # Supprimer les messages envoyÃ©s (nouvelle fonctionnalitÃ©)
            secret_menus[user_id]["step"] = "delete_sent_messages"
            sent_message = await update.message.reply_text("""ğŸ—‘ï¸ SUPPRESSION DES MESSAGES ENVOYÃ‰S

âš ï¸ ATTENTION : Cette fonctionnalitÃ© va tenter de supprimer les derniers messages diffusÃ©s Ã  tous les utilisateurs.

ğŸ“Š Limites techniques :
â€¢ Seuls les messages envoyÃ©s dans les derniÃ¨res 48h peuvent Ãªtre supprimÃ©s
â€¢ Les messages dans les groupes/canaux privÃ©s ne peuvent pas Ãªtre supprimÃ©s
â€¢ Certains utilisateurs peuvent avoir dÃ©jÃ  lu les messages

â“ Voulez-vous continuer ?

âœ… Tapez OUI pour tenter la suppression
âŒ Tapez NON pour annuler
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text.upper() == "B":
            # Statistiques complÃ¨tes
            users_data = load_users()
            blocked_users = load_blocked_users()
            admins = load_admins()
            saved_messages = load_saved_messages()
            settings = load_bot_settings()
            
            stats_msg = f"""ğŸ“Š STATISTIQUES COMPLÃˆTES ZACK PCS

ğŸ‘¥ UTILISATEURS :
â€¢ Total inscrits : {len(users_data)}
â€¢ Utilisateurs actifs : {len(users_data) - len(blocked_users)}
â€¢ Utilisateurs bloquÃ©s : {len(blocked_users)}

ğŸ‘‘ ADMINISTRATION :
â€¢ Administrateur principal : {'âœ… ConfigurÃ©' if ADMIN_CHAT_ID else 'âŒ Non configurÃ©'}
â€¢ Administrateurs secondaires : {len(admins)}
â€¢ Total admins : {1 + len(admins) if ADMIN_CHAT_ID else len(admins)}

ğŸ“§ MESSAGES :
â€¢ Messages quotidiens par dÃ©faut : {len(DAILY_MESSAGES)}
â€¢ Messages personnalisÃ©s : {len(saved_messages)}
â€¢ Total messages en rotation : {len(DAILY_MESSAGES) + len(saved_messages)}

â° CONFIGURATION :
â€¢ Heure du matin : {settings.get('morning_time', '09:00')}
â€¢ Heure du soir : {settings.get('evening_time', '18:00')}
â€¢ Code promo actif : {PROMO_CODE}

ğŸ“… DerniÃ¨re activitÃ© : {datetime.now().strftime('%d/%m/%Y %H:%M')}
ğŸ¤– Status bot : âœ… OpÃ©rationnel

ğŸ”™ Retour au menu principal
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(stats_msg)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text.upper() == "C":
            # Quitter
            if 'last_bot_message_id' in menu_state:
                try:
                    await context.bot.delete_message(
                        chat_id=user_id, 
                        message_id=menu_state['last_bot_message_id']
                    )
                except:
                    pass
            
            del secret_menus[user_id]
            await update.message.reply_text("""âœ… MENU FERMÃ‰

ğŸ” Session administrateur terminÃ©e avec succÃ¨s.
ğŸ’¡ Tapez **LMM8** Ã  nouveau pour rouvrir le menu.

ğŸ¯ Merci d'avoir utilisÃ© le systÃ¨me de gestion ZACK PCS !""")
            
        else:
            sent_message = await update.message.reply_text("""âŒ Option invalide

ğŸ¯ Choisissez une option valide :

ğŸ“‹ GESTION DES MESSAGES : 1-5
âš™ï¸ GESTION AVANCÃ‰E : 6-10
ğŸ“Š ADMINISTRATION : A, B, C

ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

    # Ici, j'ajoute les handlers pour tous les nouveaux sous-menus...
    # [Le code continue avec tous les autres handlers pour les sous-menus]
    
    # Pour Ã©conomiser l'espace, je vais ajouter les handlers principaux
    elif menu_state["step"] == "add_message":
        # [Code existant pour ajouter un message]
        await handle_add_message_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "schedule_settings":
        await handle_schedule_settings_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "admin_management":
        await handle_admin_management_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "block_user":
        await handle_block_user_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "unblock_user":
        await handle_unblock_user_step(update, context, user_id, menu_state)
    
    # [Continuer avec tous les autres handlers...]


async def handle_add_message_step(update, context, user_id, menu_state):
    """GÃ¨re l'ajout d'un nouveau message"""
    # Supprimer le message prÃ©cÃ©dent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    # DÃ©terminer le type de message
    message_type = "text"
    media_file_id = None
    content = update.message.text if update.message.text else ""
    
    if update.message.photo:
        message_type = "photo"
        media_file_id = update.message.photo[-1].file_id
        content = update.message.caption or ""
    elif update.message.video:
        message_type = "video"
        media_file_id = update.message.video.file_id
        content = update.message.caption or ""
    elif update.message.document:
        message_type = "document"
        media_file_id = update.message.document.file_id
        content = update.message.caption or ""
    
    # Sauvegarder le message
    saved_messages = load_saved_messages()
    new_message = {
        "id": len(saved_messages) + 1,
        "type": message_type,
        "content": content,
        "media_file_id": media_file_id,
        "created_date": datetime.now().isoformat()
    }
    saved_messages.append(new_message)
    save_messages(saved_messages)
    
    message_type_text = {"photo": "ğŸ–¼ï¸ Image", "video": "ğŸ¬ VidÃ©o", "document": "ğŸ“ Document", "text": "ğŸ“ Texte"}
    
    sent_message = await update.message.reply_text(f"""âœ… MESSAGE AJOUTÃ‰ AVEC SUCCÃˆS !

{message_type_text.get(message_type, "ğŸ“")} Votre message a Ã©tÃ© sauvegardÃ©.
ğŸ“Š Total de messages personnalisÃ©s : {len(saved_messages)}

ğŸ”„ Ce message peut maintenant Ãªtre utilisÃ© pour la diffusion.

ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
    
    secret_menus[user_id]["step"] = "main_menu"
    secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_schedule_settings_step(update, context, user_id, menu_state):
    """GÃ¨re les paramÃ¨tres d'horaires"""
    message_text = update.message.text
    
    # Supprimer le message prÃ©cÃ©dent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "1":
        secret_menus[user_id]["step"] = "set_morning_time"
        sent_message = await update.message.reply_text("""ğŸŒ… MODIFIER HEURE DU MATIN

â° Format attendu : HH:MM (24h)
ğŸ“ Exemples valides : 08:30, 09:00, 10:45

ğŸ’¡ Heure actuelle du matin : {current_time}

âœï¸ Tapez la nouvelle heure pour les messages du matin :
ğŸ”™ Tapez 0 pour revenir aux horaires
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""".format(
            current_time=load_bot_settings().get('morning_time', '09:00')
        ))
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    elif message_text == "2":
        secret_menus[user_id]["step"] = "set_evening_time"
        sent_message = await update.message.reply_text("""ğŸŒ† MODIFIER HEURE DU SOIR

â° Format attendu : HH:MM (24h)
ğŸ“ Exemples valides : 18:00, 19:30, 20:15

ğŸ’¡ Heure actuelle du soir : {current_time}

âœï¸ Tapez la nouvelle heure pour les messages du soir :
ğŸ”™ Tapez 0 pour revenir aux horaires
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""".format(
            current_time=load_bot_settings().get('evening_time', '18:00')
        ))
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    elif message_text == "3":
        # RÃ©initialiser les horaires
        settings = {"morning_time": "09:00", "evening_time": "18:00"}
        save_bot_settings(settings)
        
        # Reprogrammer les tÃ¢ches
        schedule.clear()
        schedule_daily_messages()
        
        sent_message = await update.message.reply_text("""âœ… HORAIRES RÃ‰INITIALISÃ‰S

ğŸŒ… Heure du matin : 09:00
ğŸŒ† Heure du soir : 18:00

ğŸ”„ Les tÃ¢ches automatiques ont Ã©tÃ© reprogrammÃ©es.

ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    elif message_text == "4":
        # Tester maintenant
        sent_message = await update.message.reply_text("""ğŸ§ª TEST DE DIFFUSION EN COURS...

ğŸ“¤ Envoi d'un message test Ã  tous les utilisateurs actifs...
â³ Veuillez patienter...""")
        
        # Lancer la diffusion de test
        await broadcast_daily_messages()
        
        await update.message.reply_text("""âœ… TEST DE DIFFUSION TERMINÃ‰ !

ğŸ“Š Le message test a Ã©tÃ© envoyÃ© selon les paramÃ¨tres actuels.
ğŸ“ VÃ©rifiez auprÃ¨s de vos utilisateurs pour confirmer la rÃ©ception.

ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        
        secret_menus[user_id]["step"] = "main_menu"


async def handle_admin_management_step(update, context, user_id, menu_state):
    """GÃ¨re la gestion des administrateurs"""
    message_text = update.message.text
    
    # Supprimer le message prÃ©cÃ©dent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "1":
        # Ajouter un admin
        secret_menus[user_id]["step"] = "add_admin"
        users_data = load_users()
        admins = load_admins()
        
        # Filtrer les utilisateurs qui ne sont pas dÃ©jÃ  admins
        available_users = {k: v for k, v in users_data.items() if k not in admins and int(k) != ADMIN_CHAT_ID}
        
        if not available_users:
            sent_message = await update.message.reply_text("""âŒ AUCUN UTILISATEUR DISPONIBLE

ğŸ“­ Tous les utilisateurs sont dÃ©jÃ  administrateurs.

ğŸ”™ Retour Ã  la gestion des admins
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        else:
            user_list = """ğŸ‘‘ PROMOUVOIR UN UTILISATEUR ADMIN

ğŸ“ Utilisateurs disponibles (tapez l'ID pour promouvoir) :

"""
            for uid, udata in list(available_users.items())[:20]:
                user_name = udata.get('name', 'Inconnu')
                username = udata.get('username', 'Pas de @')
                reg_date = udata.get('registered_date', '')[:10] if udata.get('registered_date') else 'Date inconnue'
                user_list += f"ğŸ”¹ {user_name} (@{username}) - ID: {uid}\n   ğŸ“… Inscrit le : {reg_date}\n\n"
            
            if len(available_users) > 20:
                user_list += f"... et {len(available_users) - 20} autres utilisateurs\n\n"
            
            user_list += """ğŸ“ Tapez l'ID de l'utilisateur Ã  promouvoir admin
ğŸ”™ Tapez 0 pour revenir Ã  la gestion des admins
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(user_list)
        
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_block_user_step(update, context, user_id, menu_state):
    """GÃ¨re le blocage d'un utilisateur"""
    message_text = update.message.text
    
    # Supprimer le message prÃ©cÃ©dent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "0":
        secret_menus[user_id]["step"] = "main_menu"
        sent_message = await update.message.reply_text("ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)")
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        return
    
    # VÃ©rifier si c'est un ID valide
    try:
        target_user_id = message_text.strip()
        users_data = load_users()
        blocked_users = load_blocked_users()
        
        if target_user_id not in users_data:
            sent_message = await update.message.reply_text("""âŒ UTILISATEUR INTROUVABLE

ğŸ” L'ID spÃ©cifiÃ© ne correspond Ã  aucun utilisateur inscrit.

ğŸ“ VÃ©rifiez l'ID et rÃ©essayez
ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        elif target_user_id in blocked_users:
            sent_message = await update.message.reply_text("""âš ï¸ UTILISATEUR DÃ‰JÃ€ BLOQUÃ‰

ğŸš« Cet utilisateur est dÃ©jÃ  dans la liste des utilisateurs bloquÃ©s.

ğŸ“ Choisissez un autre utilisateur
ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        elif is_admin(target_user_id):
            sent_message = await update.message.reply_text("""âŒ IMPOSSIBLE DE BLOQUER UN ADMIN

ğŸ‘‘ Vous ne pouvez pas bloquer un administrateur.

ğŸ“ Retirez d'abord ses privilÃ¨ges d'admin si nÃ©cessaire
ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        else:
            # Bloquer l'utilisateur
            user_info = users_data[target_user_id]
            blocked_users[target_user_id] = {
                "name": user_info.get('name', 'Inconnu'),
                "username": user_info.get('username', 'Pas de @'),
                "blocked_date": datetime.now().isoformat(),
                "blocked_by": user_id,
                "reason": "BloquÃ© par l'administrateur"
            }
            save_blocked_users(blocked_users)
            
            user_name = user_info.get('name', 'Inconnu')
            sent_message = await update.message.reply_text(f"""âœ… UTILISATEUR BLOQUÃ‰ AVEC SUCCÃˆS !

ğŸš« Utilisateur bloquÃ© : {user_name} (ID: {target_user_id})
ğŸ“… Date de blocage : {datetime.now().strftime('%d/%m/%Y %H:%M')}

âš ï¸ Cet utilisateur ne pourra plus :
â€¢ Recevoir de messages du bot
â€¢ Interagir avec le bot
â€¢ Utiliser les commandes

ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
    except Exception as e:
        sent_message = await update.message.reply_text("""âŒ ERREUR DE FORMAT

ğŸ”¢ Veuillez entrer un ID utilisateur valide (numÃ©rique)

ğŸ“ Exemple : 123456789
ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_unblock_user_step(update, context, user_id, menu_state):
    """GÃ¨re le dÃ©blocage d'un utilisateur"""
    message_text = update.message.text
    
    # Supprimer le message prÃ©cÃ©dent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "0":
        secret_menus[user_id]["step"] = "main_menu"
        sent_message = await update.message.reply_text("ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)")
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        return
    
    try:
        target_user_id = message_text.strip()
        blocked_users = load_blocked_users()
        
        if target_user_id not in blocked_users:
            sent_message = await update.message.reply_text("""âŒ UTILISATEUR NON TROUVÃ‰

ğŸ” L'ID spÃ©cifiÃ© ne correspond Ã  aucun utilisateur bloquÃ©.

ğŸ“ VÃ©rifiez l'ID et rÃ©essayez
ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        else:
            # DÃ©bloquer l'utilisateur
            user_info = blocked_users[target_user_id]
            user_name = user_info.get('name', 'Inconnu')
            del blocked_users[target_user_id]
            save_blocked_users(blocked_users)
            
            sent_message = await update.message.reply_text(f"""âœ… UTILISATEUR DÃ‰BLOQUÃ‰ AVEC SUCCÃˆS !

ğŸ”“ Utilisateur dÃ©bloquÃ© : {user_name} (ID: {target_user_id})
ğŸ“… Date de dÃ©blocage : {datetime.now().strftime('%d/%m/%Y %H:%M')}

âœ… Cet utilisateur peut maintenant :
â€¢ Recevoir Ã  nouveau les messages du bot
â€¢ Utiliser toutes les commandes
â€¢ Interagir normalement avec le bot

ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
    except Exception as e:
        sent_message = await update.message.reply_text("""âŒ ERREUR DE FORMAT

ğŸ”¢ Veuillez entrer un ID utilisateur valide (numÃ©rique)

ğŸ“ Exemple : 123456789
ğŸ”™ Retour au menu principal - Tapez une option (1-10, A, B, C)
ğŸšª SORTIR - Tapez SORTIR pour quitter le menu""")
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


# [Le reste du code existant pour handle_broadcast_process, etc. reste identique]
async def handle_broadcast_process(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """GÃ¨re le processus de diffusion en plusieurs Ã©tapes"""
    user_id = update.effective_user.id
    message_text = update.message.text if update.message.text else ""

    if user_id not in broadcast_states:
        return

    current_state = broadcast_states[user_id]

    # Ã‰tape 1 : RÃ©ception du message Ã  diffuser
    if current_state["step"] == "waiting_message":
        # DÃ©terminer le type de contenu
        if update.message.photo:
            current_state["media_type"] = "photo"
            current_state["media_file"] = update.message.photo[-1].file_id
            current_state["message"] = update.message.caption or ""
        elif update.message.video:
            current_state["media_type"] = "video"
            current_state["media_file"] = update.message.video.file_id
            current_state["message"] = update.message.caption or ""
        elif update.message.document:
            current_state["media_type"] = "document"
            current_state["media_file"] = update.message.document.file_id
            current_state["message"] = update.message.caption or ""
        else:
            current_state["media_type"] = "text"
            current_state["media_file"] = None
            current_state["message"] = message_text

        current_state["step"] = "waiting_confirmation"

        # Afficher le preview
        media_info = ""
        if current_state["media_type"] != "text":
            media_info = f"ğŸï¸ **Type de mÃ©dia :** {current_state['media_type'].upper()}\n"

        preview_message = f"""ğŸ“¢ **APERÃ‡U DU MESSAGE Ã€ DIFFUSER**

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
{media_info}{current_state['message']}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š **Informations de diffusion :**
ğŸ‘‘ ExpÃ©diteur : Administrateur ZACK PCS
ğŸ‘¥ Destinataires : Tous les utilisateurs actifs (non bloquÃ©s)
ğŸ“… Date d'envoi : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}

âš ï¸ **Ã‰tape 2/3 :** Voulez-vous vraiment envoyer ce message Ã  tous vos utilisateurs ?

âœ… Tapez **OUI** pour confirmer l'envoi
âŒ Tapez **NON** pour annuler la diffusion"""

        await update.message.reply_text(preview_message)

    # Ã‰tape 2 : Traitement de la confirmation
    elif current_state["step"] == "waiting_confirmation":
        if message_text.upper() == "OUI":
            # Lancer la diffusion
            current_state["step"] = "sending"

            await update.message.reply_text("""ğŸš€ **DIFFUSION EN COURS...**

ğŸ“¤ Envoi du message Ã  tous les utilisateurs actifs...
â³ Veuillez patienter...""")

            # Effectuer la diffusion
            result = await send_broadcast_with_media(current_state)

            # Afficher le rÃ©sultat
            success_message = f"""âœ… **DIFFUSION TERMINÃ‰E !**

ğŸ“Š **Rapport d'envoi :**
âœ… Messages envoyÃ©s : **{result['sent_count']}**
âŒ Ã‰checs d'envoi : **{result['failed_count']}**
ğŸ‘¥ Utilisateurs actifs : **{result['active_users']}**
ğŸš« Utilisateurs bloquÃ©s : **{result['blocked_users']}**
ğŸ“… Date/Heure : {datetime.now().strftime('%d/%m/%Y Ã  %H:%M:%S')}

ğŸ¯ Votre message a Ã©tÃ© diffusÃ© avec succÃ¨s !"""

            await update.message.reply_text(success_message)

        else:
            # Annuler la diffusion
            await update.message.reply_text("""âŒ **DIFFUSION ANNULÃ‰E**

ğŸš« La diffusion de message a Ã©tÃ© annulÃ©e.
ğŸ“ Votre message n'a pas Ã©tÃ© envoyÃ©.

ğŸ’¡ Utilisez Ã  nouveau `/broadcast` si vous souhaitez diffuser un message.""")

        # Nettoyer l'Ã©tat
        del broadcast_states[user_id]


async def send_broadcast_with_media(broadcast_state):
    """Envoie un message de diffusion avec support mÃ©dia depuis un Ã©tat de diffusion"""
    users_data = load_users()
    blocked_users = load_blocked_users()
    app = ApplicationBuilder().token(TOKEN).build()

    # Filtrer les utilisateurs actifs (non bloquÃ©s)
    active_users = {k: v for k, v in users_data.items() if k not in blocked_users}

    sent_count = 0
    failed_count = 0
    total_users = len(users_data)
    active_count = len(active_users)
    blocked_count = len(blocked_users)

    # Ajouter l'en-tÃªte ZACK PCS au message
    formatted_message = f"""ğŸ“¢ **MESSAGE OFFICIEL ZACK PCS**

{broadcast_state['message']}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Code promo : **{PROMO_CODE}**
ğŸ“± Support : {CONTACT_LINK}
ğŸ“š Infos : {INFO_LINK}"""

    # Envoyer aux utilisateurs actifs uniquement
    for user_id, user_data in active_users.items():
        try:
            if broadcast_state['media_type'] == "photo":
                await app.bot.send_photo(
                    chat_id=int(user_id), 
                    photo=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            elif broadcast_state['media_type'] == "video":
                await app.bot.send_video(
                    chat_id=int(user_id), 
                    video=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            elif broadcast_state['media_type'] == "document":
                await app.bot.send_document(
                    chat_id=int(user_id), 
                    document=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            else:
                await app.bot.send_message(
                    chat_id=int(user_id), 
                    text=formatted_message
                )
            
            sent_count += 1
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            await asyncio.sleep(0.5)

        except Exception as e:
            print(f"Erreur envoi diffusion Ã  {user_id}: {e}")
            failed_count += 1

    save_users(users_data)
    return {
        "sent_count": sent_count,
        "failed_count": failed_count,
        "total_users": total_users,
        "active_users": active_count,
        "blocked_users": blocked_count
    }


def schedule_daily_messages():
    """Programme les messages quotidiens avec horaires configurables"""
    def run_broadcast():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(broadcast_daily_messages())
        except Exception as e:
            print(f"Erreur lors de l'envoi des messages quotidiens: {e}")
        finally:
            loop.close()

    # Charger les horaires depuis les paramÃ¨tres
    settings = load_bot_settings()
    morning_time = settings.get("morning_time", "09:00")
    evening_time = settings.get("evening_time", "18:00")

    # Programmer les tÃ¢ches avec les horaires configurÃ©s
    schedule.every().day.at(morning_time).do(run_broadcast)
    schedule.every().day.at(evening_time).do(run_broadcast)

    print(f"ğŸ“… Messages quotidiens programmÃ©s Ã  {morning_time} et {evening_time}")

    while True:
        schedule.run_pending()
        time.sleep(30)


if __name__ == "__main__":
    print("ğŸš€ DÃ©marrage du bot ZACK PCS avec systÃ¨me administrateur avancÃ©...")

    # CrÃ©ation de l'application
    app = ApplicationBuilder().token(TOKEN).build()

    # Ajout des handlers pour texte, images et vidÃ©os
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("stats", stats))
    app.add_handler(CommandHandler("test", send_test_message))
    app.add_handler(CommandHandler("broadcast", broadcast_command))
    
    # NOUVELLES COMMANDES RÃ‰VOLUTIONNAIRES
    app.add_handler(CommandHandler("profile", profile_command))
    app.add_handler(CommandHandler("loyalty", loyalty_command))
    app.add_handler(CommandHandler("analytics", analytics_command))
    
    # Handler pour tous les types de messages (texte, photo, vidÃ©o, document)
    app.add_handler(MessageHandler(
        (filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL) & ~filters.COMMAND, 
        handle_message
    ))

    # DÃ©marrer le scheduler dans un thread sÃ©parÃ©
    scheduler_thread = threading.Thread(target=schedule_daily_messages, daemon=True)
    scheduler_thread.start()

    print("ğŸ¤– Bot ZACK PCS dÃ©marrÃ© avec systÃ¨me administrateur complet !")
    print("ğŸ” Menu administrateur : Tapez LMM8")
    print("â° Messages automatiques : Horaires configurables")
    print(f"ğŸ”‘ Code promo actif : {PROMO_CODE}")
    print("ğŸ–¼ï¸ Support complet : Texte, Images, VidÃ©os !")
    print("ğŸ‘‘ Gestion complÃ¨te : Admins, blocages, horaires, diffusion...")

    # DÃ©marrage du bot
    app.run_polling()
