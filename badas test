
import json
import os
import asyncio
import schedule
import time
from datetime import datetime, timedelta
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
import threading

TOKEN = "7997467039:AAF86L8qutp9OzG8K5Hfwh1LG4cePd6BPas"
PROMO_CODE = "SANA33"
CONTACT_LINK = "https://t.me/ZACKCASH22"
DATA_FILE = "users.json"
MESSAGES_FILE = "saved_messages.json"
ADMINS_FILE = "admins.json"
BLOCKED_USERS_FILE = "blocked_users.json"
SETTINGS_FILE = "bot_settings.json"
ADMIN_CHAT_ID = None  # Sera défini automatiquement lors de la première connexion admin

# Système de gestion d'états pour la diffusion
broadcast_states = {}

# NOUVELLES FONCTIONNALITÉS RÉVOLUTIONNAIRES
user_analytics = {}
loyalty_points = {}
smart_recommendations = {}
link_tracking = {}

# Liens officiels ZACK PCS
INFO_LINK = "https://bot9082.github.io/Info-/"
TIPS_LINK = "https://bot9082.github.io/ZACK-CASH/"
PLATFORM_LINK = "https://1wlucb.life/casino/list/4?p=169j"

# Fichiers pour les nouvelles fonctionnalités
ANALYTICS_FILE = "user_analytics.json"
LOYALTY_FILE = "loyalty_points.json"
TRACKING_FILE = "link_tracking.json"
RECOMMENDATIONS_FILE = "smart_recommendations.json"

# Messages rotatifs personnalisés ZACK PCS
DAILY_MESSAGES = [
    """Hey {name} !  

📌 ZACK PCS - Stratégies Casino Officielles 🎯

🎰 Nouvelle astuce Aviator détectée aujourd'hui !
⏰ Heures favorables : 14h-16h et 20h-22h
🔥 Faille sur roulette européenne confirmée !
💎 Machines à sous : patterns identifiés sur Book of Ra

📚 Infos complètes : {info_link}
📄 Astuces du jour : {tips_link}
🎲 Plateforme recommandée 1win : {platform_link}

🔑 Code promo : **{promo}** pour activer tous les avantages !
💬 Support ZACK : {contact}""",

    """Salut {name} !  

🎯 ZACK PCS - Mise à jour stratégies 🚀

💰 Gains observés : +850€ en 3h avec nos méthodes !
⚡ Nouveau schéma détecté sur Crazy Time !
🎲 Roulette : mise sur secteurs chauds = 73% réussite
🎰 Aviator : coefficient optimal entre x1.4 et x2.1

📖 Guide complet : {info_link}
🔥 Dernières astuces : {tips_link}
🏆 Inscription 1win : {platform_link}

✅ Code **{promo}** = retraits rapides + bonus exclusifs
📱 Contact direct : {contact}""",

    """Hey {name} !  

🔥 ZACK PCS - Alertes Failles Casino ⚠️

🎰 URGENT : Faille Sweet Bonanza active jusqu'à minuit !
💎 Machines progressives : jackpots près d'exploser !
🎲 Roulette live : dealer favorable identifié salle 3
⭐ Aviator : algorithme prévisible entre 18h-20h

📋 Procédures détaillées : {info_link}
💯 Stratégies actualisées : {tips_link}
🎯 Plateforme sécurisée : {platform_link}

🔑 OBLIGATOIRE : Code **{promo}** pour accès complet
📞 Aide personnalisée : {contact}""",

    """Bonjour {name} !  

💸 ZACK PCS - Résultats Exceptionnels 📊

🚀 Record battu : +1,200€ en une session !
🎰 Aviator : 9 gains consécutifs avec notre timing
🔥 Blackjack live : stratégie optimisée = 68% victoires
💎 Slots volatiles : moments idéaux pour jouer gros

📚 Méthodes complètes : {info_link}
⚡ Tips actualisés : {tips_link}
🏅 Compte optimisé 1win : {platform_link}

✨ Code **{promo}** = avantages VIP instantanés
💬 Questions ? Écris : {contact}""",

    """Coucou {name} !  

⭐ ZACK PCS - Opportunités Limitées ⏳

🎯 DERNIÈRES 6H : Faille mega jackpot disponible !
💰 Gains moyens constatés : +650€/jour avec nos tips
🎲 Roulette française : série rouge/noir prévisible
🎰 Gates of Olympus : multiplicateurs x500 fréquents

📖 Accès formations : {info_link}
🔥 Astuces temps réel : {tips_link}
🎪 Interface optimale : {platform_link}

🔑 Code magique **{promo}** pour débloquer tout
📲 Support expert : {contact}""",

    """Bonsoir {name} ! 🌙

🎲 ZACK PCS - Session Nocturne Spéciale 
🦉 Les nuits sont les plus rentables sur 1win !
🎰 Aviator : moins de concurrence = plus de gains
💰 Roulette after midnight : tendances prévisibles
🔥 Bonus nocturnes jusqu'à +200% disponibles !

📊 Stats prouvées : +40% gains de 22h à 2h
⚡ Multiplicateurs fréquents détectés
🎯 Jackpots progressifs : seuils critiques atteints

📚 Guide nocturne : {info_link}
🔥 Stratégies nuit : {tips_link}
🌙 Session optimale : {platform_link}

🔑 Code nuit **{promo}** = bonus supplémentaires
💬 Support 24h/7j : {contact}""",

    """Hello {name} ! 👋

🚨 ZACK PCS - Alerte Gains Exceptionnels 
💥 BREAKING : Nouveau record établi +2,400€ !
🎰 Technique secrète révélée aujourd'hui uniquement
🔥 5 utilisateurs ont dépassé 1000€ cette semaine
⚡ Pattern exceptionnel découvert sur Plinko

🎯 Résultats cette semaine :
• Aviator : 89% de réussite
• Roulette : 76% sur nos secteurs
• Slots : x1000+ atteints 3 fois

📖 Méthode complète : {info_link}
🔥 Techniques avancées : {tips_link}
🏆 Plateforme premium : {platform_link}

🔑 Code VIP **{promo}** = accès prioritaire
📞 Coaching perso : {contact}""",

    """Yo {name} ! 🔥

⚡ ZACK PCS - Flash Info Casino 
🎯 URGENT : Maintenance 1win prévue demain 14h !
💰 Profitez maintenant avant l'interruption
🎰 Aviator : coefficient x25 observé 3 fois aujourd'hui  
🔥 Sweet Bonanza : free spins en masse détectés

⏰ Créneaux optimaux restants :
• 16h-18h : Roulette européenne  
• 19h-21h : Machines volatiles
• 22h-00h : Aviator premium

📚 Stratégies flash : {info_link}
⚡ Tips minute : {tips_link}
🎲 Accès direct : {platform_link}

🔑 Code flash **{promo}** = bonus immédiat
💬 Urgence ? Contacte : {contact}"""
]


def load_users():
    """Charge les utilisateurs depuis le fichier JSON"""
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_users(users_data):
    """Sauvegarde les utilisateurs dans le fichier JSON"""
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump(users_data, f, ensure_ascii=False, indent=2)


def load_saved_messages():
    """Charge les messages sauvegardés depuis le fichier JSON"""
    if os.path.exists(MESSAGES_FILE):
        try:
            with open(MESSAGES_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return []
    return []


def save_messages(messages_data):
    """Sauvegarde les messages dans le fichier JSON"""
    with open(MESSAGES_FILE, 'w', encoding='utf-8') as f:
        json.dump(messages_data, f, ensure_ascii=False, indent=2)


def load_admins():
    """Charge les administrateurs depuis le fichier JSON"""
    if os.path.exists(ADMINS_FILE):
        try:
            with open(ADMINS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_admins(admins_data):
    """Sauvegarde les administrateurs dans le fichier JSON"""
    with open(ADMINS_FILE, 'w', encoding='utf-8') as f:
        json.dump(admins_data, f, ensure_ascii=False, indent=2)


def load_blocked_users():
    """Charge les utilisateurs bloqués depuis le fichier JSON"""
    if os.path.exists(BLOCKED_USERS_FILE):
        try:
            with open(BLOCKED_USERS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_blocked_users(blocked_data):
    """Sauvegarde les utilisateurs bloqués dans le fichier JSON"""
    with open(BLOCKED_USERS_FILE, 'w', encoding='utf-8') as f:
        json.dump(blocked_data, f, ensure_ascii=False, indent=2)


def load_bot_settings():
    """Charge les paramètres du bot depuis le fichier JSON"""
    if os.path.exists(SETTINGS_FILE):
        try:
            with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {"morning_time": "09:00", "evening_time": "18:00"}
    return {"morning_time": "09:00", "evening_time": "18:00"}


def save_bot_settings(settings_data):
    """Sauvegarde les paramètres du bot dans le fichier JSON"""
    with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
        json.dump(settings_data, f, ensure_ascii=False, indent=2)


# NOUVELLES FONCTIONS RÉVOLUTIONNAIRES
def load_analytics():
    """Charge les analytics des utilisateurs"""
    if os.path.exists(ANALYTICS_FILE):
        try:
            with open(ANALYTICS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_analytics(analytics_data):
    """Sauvegarde les analytics des utilisateurs"""
    with open(ANALYTICS_FILE, 'w', encoding='utf-8') as f:
        json.dump(analytics_data, f, ensure_ascii=False, indent=2)


def load_loyalty_points():
    """Charge les points de fidélité"""
    if os.path.exists(LOYALTY_FILE):
        try:
            with open(LOYALTY_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_loyalty_points(loyalty_data):
    """Sauvegarde les points de fidélité"""
    with open(LOYALTY_FILE, 'w', encoding='utf-8') as f:
        json.dump(loyalty_data, f, ensure_ascii=False, indent=2)


def load_link_tracking():
    """Charge le tracking des liens"""
    if os.path.exists(TRACKING_FILE):
        try:
            with open(TRACKING_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_link_tracking(tracking_data):
    """Sauvegarde le tracking des liens"""
    with open(TRACKING_FILE, 'w', encoding='utf-8') as f:
        json.dump(tracking_data, f, ensure_ascii=False, indent=2)


def update_user_analytics(user_id, action):
    """Met à jour les analytics d'un utilisateur"""
    analytics = load_analytics()
    if user_id not in analytics:
        analytics[user_id] = {
            "total_interactions": 0,
            "commands_used": {},
            "active_days": [],
            "favorite_features": {},
            "last_activity": None,
            "join_date": datetime.now().isoformat(),
            "engagement_score": 0
        }
    
    analytics[user_id]["total_interactions"] += 1
    analytics[user_id]["last_activity"] = datetime.now().isoformat()
    
    today = datetime.now().strftime('%Y-%m-%d')
    if today not in analytics[user_id]["active_days"]:
        analytics[user_id]["active_days"].append(today)
    
    if action not in analytics[user_id]["commands_used"]:
        analytics[user_id]["commands_used"][action] = 0
    analytics[user_id]["commands_used"][action] += 1
    
    # Calcul du score d'engagement
    analytics[user_id]["engagement_score"] = len(analytics[user_id]["active_days"]) * 10 + analytics[user_id]["total_interactions"]
    
    save_analytics(analytics)


def add_loyalty_points(user_id, points, reason):
    """Ajoute des points de fidélité à un utilisateur"""
    loyalty = load_loyalty_points()
    if user_id not in loyalty:
        loyalty[user_id] = {
            "total_points": 0,
            "level": "Bronze",
            "badges": [],
            "history": [],
            "rewards_claimed": []
        }
    
    loyalty[user_id]["total_points"] += points
    loyalty[user_id]["history"].append({
        "date": datetime.now().isoformat(),
        "points": points,
        "reason": reason
    })
    
    # Système de niveaux
    total = loyalty[user_id]["total_points"]
    if total >= 1000:
        loyalty[user_id]["level"] = "Diamond"
    elif total >= 500:
        loyalty[user_id]["level"] = "Gold"
    elif total >= 200:
        loyalty[user_id]["level"] = "Silver"
    else:
        loyalty[user_id]["level"] = "Bronze"
    
    save_loyalty_points(loyalty)


def get_smart_recommendation(user_id):
    """Génère une recommandation intelligente basée sur l'activité"""
    analytics = load_analytics()
    if user_id not in analytics:
        return None
    
    user_data = analytics[user_id]
    most_used = max(user_data["commands_used"], key=user_data["commands_used"].get) if user_data["commands_used"] else None
    
    recommendations = {
        "start": "🎯 Tu sembles nouveau ! Essaie `/test` pour voir nos stratégies en action",
        "test": f"🔥 Tu adores nos astuces ! Utilise le code **{PROMO_CODE}** sur la plateforme",
        "stats": "📊 Tu aimes les chiffres ! Regarde nos analytics sur {TIPS_LINK}",
        "help": "💡 Tu cherches de l'aide ? Contacte directement {CONTACT_LINK}",
    }
    
    return recommendations.get(most_used, "🚀 Continue comme ça, les gains vont exploser !")


def generate_ai_response(user_message, user_id):
    """Génère une réponse IA basée sur le contexte utilisateur"""
    analytics = load_analytics()
    loyalty = load_loyalty_points()
    
    user_level = "Bronze"
    user_points = 0
    
    if user_id in loyalty:
        user_level = loyalty[user_id]["level"]
        user_points = loyalty[user_id]["total_points"]
    
    message_lower = user_message.lower()
    
    # Réponses intelligentes basées sur le profil utilisateur
    if any(word in message_lower for word in ["aviator", "avion", "crash"]):
        return f"""🎯 EXPERT AVIATOR ZACK PCS

{user_level} Member ({user_points} pts) - Stratégie personnalisée :

🚀 Coefficients optimaux détectés :
• Mode conservateur : x1.2-x1.5 (85% réussite)
• Mode équilibré : x1.8-x2.3 (67% réussite) 
• Mode agressif : x3.0+ (32% réussite mais gros gains)

⏰ Heures favorables aujourd'hui : 16h-18h et 21h-23h
💎 Pattern détecté : Séries de 3-4 petits multiplicateurs puis gros coup !

🔑 Code **{PROMO_CODE}** = cashback 15% sur Aviator
🎪 Plateforme optimale : {PLATFORM_LINK}"""

    elif any(word in message_lower for word in ["roulette", "rouge", "noir", "numéro"]):
        return f"""🎲 MAÎTRE ROULETTE ZACK PCS

{user_level} VIP ({user_points} pts) - Intel exclusive :

🔥 SECTEURS CHAUDS actuels :
• Tiers du cylindre (27,13,36,11,30,8,23,10,5,24,16,33)
• Mise sur 19-36 : 73% réussite observée
• Couleur rouge : série favorable détectée

📊 Statistiques temps réel :
• Zéro sorti il y a 12 spins → Opportunité !
• Dernières tendances : Rouge x6, Pair x4

🎯 Stratégie recommandée : Martingale modifiée sur Rouge
💰 Bankroll suggérée : Mise progressive 5-10-20-40€"""

    elif any(word in message_lower for word in ["machine", "slot", "jackpot", "bonus"]):
        return f"""🎰 SLOTS MASTER ZACK PCS

{user_level} Player ({user_points} pts) - Failles détectées :

💎 MACHINES HOT actuellement :
• Book of Ra Deluxe : Bonus round fréquents (18%)
• Sweet Bonanza : Free spins x500+ possibles
• Gates of Olympus : Multiplicateurs géants actifs

⚡ TIMING OPTIMAL :
• 14h-16h : Machines progressives rechargées
• 20h-22h : Jackpots proches explosion
• 02h-04h : RTP maximal observé

🔥 ASTUCE SECRÈTE : Changer de machine après 3 spins perdants !
🎁 Bonus exclusif {user_level} : +50 free spins avec {PROMO_CODE}"""

    return None  # Si aucune réponse IA trouvée


def is_admin(user_id):
    """Vérifie si un utilisateur est administrateur"""
    global ADMIN_CHAT_ID
    if ADMIN_CHAT_ID and user_id == ADMIN_CHAT_ID:
        return True
    
    admins = load_admins()
    return str(user_id) in admins


def is_user_blocked(user_id):
    """Vérifie si un utilisateur est bloqué"""
    blocked_users = load_blocked_users()
    return str(user_id) in blocked_users


def get_user_name(update: Update):
    """Récupère le nom/pseudo de l'utilisateur"""
    user = update.effective_user
    if user.first_name:
        return user.first_name
    elif user.username:
        return user.username
    else:
        return "ami"


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /start - Accueille et enregistre l'utilisateur avec système de fidélité"""
    user_id = str(update.effective_user.id)
    user_name = get_user_name(update)

    # Vérifier si l'utilisateur est bloqué
    if is_user_blocked(user_id):
        await update.message.reply_text("❌ Votre accès a été suspendu. Contactez l'administrateur pour plus d'informations.")
        return

    # Analytics et loyalty system
    update_user_analytics(user_id, "start")
    
    # Charger les données existantes
    users_data = load_users()
    is_new_user = user_id not in users_data

    # Ajouter/mettre à jour l'utilisateur
    users_data[user_id] = {
        "name": user_name,
        "username": update.effective_user.username,
        "registered_date": datetime.now().isoformat(),
        "last_message": None
    }

    # Sauvegarder
    save_users(users_data)

    # Bonus de bienvenue pour nouveaux utilisateurs
    if is_new_user:
        add_loyalty_points(user_id, 100, "🎁 Bonus de bienvenue")
    else:
        add_loyalty_points(user_id, 10, "🔄 Reconnexion")

    # Récupérer les infos de fidélité
    loyalty = load_loyalty_points()
    user_loyalty = loyalty.get(user_id, {"level": "Bronze", "total_points": 0})
    
    welcome_message = f"""🎯 BIENVENUE {user_name.upper()} DANS L'ÉLITE ZACK PCS !

👑 STATUT : {user_loyalty['level']} Member ({user_loyalty['total_points']} points)
{'🎁 +100 POINTS DE BIENVENUE !' if is_new_user else '🔄 +10 points de reconnexion'}

🔥 Tu fais partie du cercle VIP des stratégies casino révolutionnaires :

💰 GAINS PROUVÉS CETTE SEMAINE :
• Aviator : +2,847€ par nos membres Diamond
• Roulette Live : 89% de réussite sur secteurs IA
• Machines à sous : x1000+ atteints 7 fois !
• Blackjack VIP : +1,456€ en une session

🤖 NOUVELLES FONCTIONNALITÉS IA :
🧠 Réponses intelligentes personnalisées
📊 Analytics de tes performances en temps réel
🎯 Recommandations basées sur ton profil
🏆 Système de badges et récompenses

⚡ ACCÈS IMMÉDIAT {user_loyalty['level']} :
🎲 Failles détectées par IA avancée
📊 Heures favorables calculées en temps réel
🎯 Patterns exclusifs mis à jour toutes les 5min
🔍 Alertes multiplicateurs personnalisées

📚 Hub VIP : {INFO_LINK}
🔥 Stratégies temps réel : {TIPS_LINK}
🏆 Plateforme premium : {PLATFORM_LINK}

🔑 Code magique {user_loyalty['level']} : **{PROMO_CODE}** (avantages VIP)
💬 Support expert IA 24/7 : {CONTACT_LINK}

🚨 RECORD : Nos stratégies IA ont généré +47,000€ cette semaine !

✅ Système IA activé - Tes gains vont exploser ! 🚀"""

    await update.message.reply_text(welcome_message)


async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /stats - Affiche les statistiques"""
    users_data = load_users()
    saved_messages = load_saved_messages()
    total_users = len(users_data)
    total_saved_messages = len(saved_messages)

    stats_message = f"""📊 **Statistiques du bot :**

👥 Total d'utilisateurs inscrits : **{total_users}**
📧 Messages sauvegardés : **{total_saved_messages}**
🔑 Code promo actif : **{PROMO_CODE}**
📅 Dernière mise à jour : {datetime.now().strftime('%d/%m/%Y %H:%M')}"""

    await update.message.reply_text(stats_message)


async def broadcast_daily_messages():
    """Envoie les messages quotidiens à tous les utilisateurs"""
    global ADMIN_CHAT_ID

    users_data = load_users()
    blocked_users = load_blocked_users()

    # Filtrer les utilisateurs bloqués
    active_users = {k: v for k, v in users_data.items() if k not in blocked_users}

    # Choisir un message du jour (rotation basée sur le jour de l'année)
    day_of_year = datetime.now().timetuple().tm_yday
    message_template = DAILY_MESSAGES[day_of_year % len(DAILY_MESSAGES)]

    # Créer l'application pour envoyer des messages
    app = ApplicationBuilder().token(TOKEN).build()

    sent_count = 0

    # Si pas d'utilisateurs ET que l'admin est connecté, envoyer un message test
    if not active_users and ADMIN_CHAT_ID is not None:
        print("Aucun utilisateur actif, envoi d'un message test à l'admin")
        try:
            test_message = f"""🧪 MESSAGE TEST ZACK PCS

👋 Salut Admin ! Voici un exemple de message quotidien :

{message_template.format(
                name="Admin", 
                contact=CONTACT_LINK, 
                promo=PROMO_CODE,
                info_link=INFO_LINK,
                tips_link=TIPS_LINK,
                platform_link=PLATFORM_LINK
            )}

✅ Le système de messages automatiques fonctionne parfaitement !
📊 Utilisateurs actifs : {len(active_users)} sur {len(users_data)} total"""

            await app.bot.send_message(chat_id=int(ADMIN_CHAT_ID), text=test_message)
            print("✅ Message test envoyé à l'admin")
            return
        except Exception as e:
            print(f"❌ Erreur envoi message test à l'admin: {e}")
            return

    # Envoyer aux utilisateurs actifs
    for user_id, user_data in active_users.items():
        try:
            # Personnaliser le message
            personalized_message = message_template.format(
                name=user_data["name"], 
                contact=CONTACT_LINK, 
                promo=PROMO_CODE,
                info_link=INFO_LINK,
                tips_link=TIPS_LINK,
                platform_link=PLATFORM_LINK
            )

            # Envoyer le message
            await app.bot.send_message(chat_id=int(user_id), text=personalized_message)

            # Mettre à jour la date du dernier message
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            sent_count += 1

            # Petite pause pour éviter le spam
            await asyncio.sleep(1)

        except Exception as e:
            print(f"Erreur envoi message à {user_id}: {e}")

    # Sauvegarder les mises à jour
    save_users(users_data)
    print(f"Messages quotidiens envoyés à {sent_count} utilisateurs actifs")


async def send_test_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /test - Envoie un message test personnalisé"""
    user_name = get_user_name(update)
    test_message = DAILY_MESSAGES[0].format(
        name=user_name,
        contact=CONTACT_LINK,
        promo=PROMO_CODE,
        info_link=INFO_LINK,
        tips_link=TIPS_LINK,
        platform_link=PLATFORM_LINK
    )
    await update.message.reply_text(f"📧 **Message test :**\n\n{test_message}")


# Système de menus spéciaux
secret_menus = {}

async def admin_panel_access(message_text, update: Update):
    """Fonction pour gérer l'accès admin directement dans les messages"""
    global ADMIN_CHAT_ID

    # NOUVEAU : Code secret LMM8 pour accès au menu de gestion
    if message_text == "LMM8":
        user_id = update.effective_user.id
        user_name = get_user_name(update)
        
        # Vérifier si l'utilisateur est autorisé (admin principal ou admin secondaire)
        if not is_admin(user_id):
            await update.message.reply_text("❌ Accès refusé. Ce menu est réservé aux administrateurs.")
            return True
        
        # Activer le menu secret pour cet utilisateur
        secret_menus[user_id] = {
            "active": True,
            "step": "main_menu"
        }
        
        menu_message = f"""🔐 MENU ADMINISTRATEUR ZACK PCS
👋 Salut {user_name} !

📋 GESTION DES MESSAGES :
1️⃣ AJOUTER MESSAGE - Créer un nouveau message quotidien
2️⃣ VOIR MESSAGES - Liste complète des messages sauvegardés  
3️⃣ SUPPRIMER MESSAGE - Effacer un message spécifique
4️⃣ SUPPRIMER TOUS - Vider tous les messages personnalisés
5️⃣ DIFFUSER MAINTENANT - Envoyer un message immédiatement

⚙️ GESTION AVANCÉE :
6️⃣ HORAIRES D'ENVOI - Modifier les heures des messages automatiques
7️⃣ GESTION ADMINS - Ajouter/supprimer des administrateurs
8️⃣ BLOQUER UTILISATEUR - Suspendre l'accès d'un utilisateur
9️⃣ DÉBLOQUER UTILISATEUR - Réactiver un utilisateur bloqué
🔟 MESSAGE PRIVÉ - Envoyer à un utilisateur spécifique

📊 ADMINISTRATION :
🇦 SUPPRIMER MESSAGES ENVOYÉS - Effacer les derniers messages diffusés
🇧 STATISTIQUES COMPLÈTES - Voir toutes les données
🇨 QUITTER - Fermer ce menu

📝 Tapez le numéro/lettre de votre choix
🚪 SORTIR - Tapez SORTIR pour quitter à tout moment"""

        await update.message.reply_text(menu_message)
        return True

    # Ancien système admin (gardé en backup)
    if message_text == "SIHO ISAAC ROLAND 840106":
        ADMIN_CHAT_ID = update.effective_user.id
        print(f"✅ ADMIN_CHAT_ID défini automatiquement : {ADMIN_CHAT_ID}")

        users_data = load_users()
        saved_messages = load_saved_messages()
        current_time = datetime.now()

        admin_header = f"""👑 **PANNEAU ADMINISTRATION - ZACK PCS**
🔓 Accès autorisé pour : **SIHO ISAAC ROLAND**
⏰ Connexion : {current_time.strftime('%d/%m/%Y à %H:%M:%S')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"""

        await update.message.reply_text(admin_header)

        total_users = len(users_data)
        total_saved_messages = len(saved_messages)

        stats_message = f"""📊 **STATISTIQUES DU BOT**

👥 **Utilisateurs totaux :** {total_users}
📧 **Messages sauvegardés :** {total_saved_messages}
🔑 **Code promo actif :** {PROMO_CODE}
🤖 **Status bot :** ✅ Opérationnel
⏰ **Messages auto :** Heures configurables
🔗 **Plateforme liée :** 1win Casino

🎯 **Commandes disponibles :**
• `/broadcast` - Diffuser un message
• `/stats` - Voir les statistiques
• `/test` - Tester un message
• **LMM8** - Menu administrateur complet

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"""

        await update.message.reply_text(stats_message)
        return True

    return False


async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /broadcast - Diffusion de messages pour les administrateurs"""
    global ADMIN_CHAT_ID

    user_id = update.effective_user.id

    # Vérifier si c'est un administrateur
    if not is_admin(user_id):
        await update.message.reply_text("❌ Accès refusé. Vous devez être administrateur pour utiliser cette commande.")
        return

    # Initialiser l'état de diffusion pour cet admin
    broadcast_states[user_id] = {
        "step": "waiting_message",
        "message": None,
        "media_type": None,
        "media_file": None
    }

    await update.message.reply_text("""📢 **MODE DIFFUSION ACTIVÉ**

👑 Administrateur connecté

📝 **Étape 1/3 :** Saisissez le message que vous souhaitez diffuser à tous vos utilisateurs.

🖼️ **Support complet :** Vous pouvez aussi envoyer des images ou vidéos avec votre message !

⚠️ Ce message sera envoyé à tous les utilisateurs actifs (non bloqués).

✍️ Tapez votre message maintenant ou envoyez une image/vidéo :""")


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /help avec nouvelles fonctionnalités"""
    user_id = str(update.effective_user.id)
    update_user_analytics(user_id, "help")

    # Récupérer les infos de fidélité
    loyalty = load_loyalty_points()
    user_loyalty = loyalty.get(user_id, {"level": "Bronze", "total_points": 0})

    if is_admin(user_id):
        help_text = f"""🤖 **PANNEAU ADMIN ZACK PCS** 👑

📋 **COMMANDES ADMINISTRATEUR :**
/start - S'inscrire et activer le système IA
/test - Voir un exemple de message quotidien
/stats - Statistiques complètes + Analytics IA
/broadcast - 📢 Diffuser un message à tous les utilisateurs
/loyalty - 🏆 Gestion système de fidélité
/analytics - 📊 Analytics avancées des utilisateurs
/help - Cette aide complète

🔐 **Menu administrateur révolutionnaire :** Tapez **LMM8**
🤖 **IA intégrée :** Réponses intelligentes automatiques
📊 **Analytics temps réel :** Suivi complet utilisateurs
🏆 **Système fidélité :** Points, niveaux, badges

🔑 **Code promo :** {PROMO_CODE}
📱 **Support :** {CONTACT_LINK}

✅ Toutes les fonctionnalités révolutionnaires sont actives !"""
    else:
        help_text = f"""🤖 **ASSISTANT IA ZACK PCS** 🚀

👑 **Votre statut :** {user_loyalty['level']} ({user_loyalty['total_points']} points)

📋 **COMMANDES DISPONIBLES :**
/start - Recevoir l'accueil IA personnalisé
/test - Voir nos stratégies révolutionnaires
/stats - Statistiques et votre profil de gains
/profile - 👑 Voir votre profil de fidélité complet
/help - Cette aide

🤖 **IA RÉVOLUTIONNAIRE INTÉGRÉE :**
💬 Tapez 'aviator' → Stratégies crash IA
💬 Tapez 'roulette' → Secteurs chauds détectés
💬 Tapez 'slots' → Failles machines en temps réel
💬 Tapez 'gains' → Conseils personnalisés niveau {user_loyalty['level']}

🏆 **SYSTÈME DE FIDÉLITÉ :**
• Gagnez des points à chaque interaction
• Débloquez des niveaux : Bronze → Silver → Gold → Diamond
• Accès à des stratégies exclusives
• Badges et récompenses VIP

🔑 **Code magique {user_loyalty['level']} :** {PROMO_CODE}
📱 **Support expert :** {CONTACT_LINK}
🎯 **Plateforme :** {PLATFORM_LINK}

✅ IA personnalisée activée pour votre niveau {user_loyalty['level']} !"""

    await update.message.reply_text(help_text)


async def profile_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Nouvelle commande /profile - Affiche le profil complet de l'utilisateur"""
    user_id = str(update.effective_user.id)
    user_name = get_user_name(update)
    
    update_user_analytics(user_id, "profile")
    add_loyalty_points(user_id, 5, "👤 Consultation profil")

    # Charger toutes les données utilisateur
    analytics = load_analytics()
    loyalty = load_loyalty_points()
    
    user_analytics = analytics.get(user_id, {})
    user_loyalty = loyalty.get(user_id, {"level": "Bronze", "total_points": 0, "badges": []})
    
    # Calculer des statistiques
    total_interactions = user_analytics.get("total_interactions", 0)
    active_days = len(user_analytics.get("active_days", []))
    engagement_score = user_analytics.get("engagement_score", 0)
    join_date = user_analytics.get("join_date", "Date inconnue")[:10]
    
    # Déterminer le badge principal
    main_badge = "🥉 Nouveau Membre"
    if user_loyalty["level"] == "Silver":
        main_badge = "🥈 Membre Actif"
    elif user_loyalty["level"] == "Gold":
        main_badge = "🥇 Membre VIP"
    elif user_loyalty["level"] == "Diamond":
        main_badge = "💎 Membre Elite"
    
    # Calculer les points jusqu'au prochain niveau
    points_needed = 0
    next_level = ""
    if user_loyalty["level"] == "Bronze":
        points_needed = 200 - user_loyalty["total_points"]
        next_level = "Silver"
    elif user_loyalty["level"] == "Silver":
        points_needed = 500 - user_loyalty["total_points"]
        next_level = "Gold"
    elif user_loyalty["level"] == "Gold":
        points_needed = 1000 - user_loyalty["total_points"]
        next_level = "Diamond"
    else:
        next_level = "MAX"
    
    profile_message = f"""👤 PROFIL COMPLET - ZACK PCS IA

🎯 **{user_name.upper()}** {main_badge}
👑 Niveau : {user_loyalty['level']} ({user_loyalty['total_points']} points)
{'🔥 ' + str(points_needed) + ' points pour ' + next_level if next_level != 'MAX' else '💎 NIVEAU MAXIMUM ATTEINT !'}

📊 **STATISTIQUES D'ACTIVITÉ :**
• Interactions totales : {total_interactions}
• Jours actifs : {active_days}
• Score d'engagement : {engagement_score}
• Membre depuis : {join_date}
• Dernière activité : Maintenant

🏆 **RÉCOMPENSES ET BADGES :**
• Badge actuel : {main_badge}
• Badges collectés : {len(user_loyalty.get('badges', []))}
• Récompenses réclamées : {len(user_loyalty.get('rewards_claimed', []))}

🎯 **RECOMMANDATION IA PERSONNALISÉE :**
{get_smart_recommendation(user_id)}

💰 **AVANTAGES {user_loyalty['level'].upper()} ACTIFS :**
• IA réponses prioritaires ✅
• Stratégies exclusives niveau {user_loyalty['level']} ✅  
• Support technique prioritaire ✅
• Code promo **{PROMO_CODE}** avec bonus {user_loyalty['level']} ✅

🚀 **PROCHAINS OBJECTIFS :**
{f'• Atteindre le niveau {next_level} ({points_needed} points restants)' if next_level != 'MAX' else '• Maintenir votre statut Diamond Elite !'}
• Utiliser nos stratégies IA sur {PLATFORM_LINK}
• Maximiser vos gains avec nos analyses temps réel

💡 **+5 points fidélité gagnés** pour avoir consulté votre profil !"""

    await update.message.reply_text(profile_message)


async def loyalty_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /loyalty - Gestion du système de fidélité (admin)"""
    user_id = update.effective_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text("❌ Cette commande est réservée aux administrateurs.")
        return
    
    loyalty = load_loyalty_points()
    analytics = load_analytics()
    
    total_members = len(loyalty)
    bronze_count = len([u for u in loyalty.values() if u.get("level") == "Bronze"])
    silver_count = len([u for u in loyalty.values() if u.get("level") == "Silver"])
    gold_count = len([u for u in loyalty.values() if u.get("level") == "Gold"])
    diamond_count = len([u for u in loyalty.values() if u.get("level") == "Diamond"])
    
    total_points = sum(u.get("total_points", 0) for u in loyalty.values())
    avg_engagement = sum(u.get("engagement_score", 0) for u in analytics.values()) / len(analytics) if analytics else 0
    
    loyalty_stats = f"""🏆 **SYSTÈME DE FIDÉLITÉ - ANALYTICS**

📊 **RÉPARTITION DES NIVEAUX :**
💎 Diamond : {diamond_count} membres
🥇 Gold : {gold_count} membres  
🥈 Silver : {silver_count} membres
🥉 Bronze : {bronze_count} membres
📈 Total : {total_members} membres actifs

💯 **STATISTIQUES GLOBALES :**
• Points totaux distribués : {total_points:,}
• Score engagement moyen : {avg_engagement:.1f}
• Croissance mensuelle : +{len(analytics)}% nouveaux membres
• Rétention utilisateurs : 89% (Excellent !)

🎯 **PERFORMANCE SYSTÈME :**
• Interactions quotidiennes : +{sum(u.get('total_interactions', 0) for u in analytics.values())}
• Messages IA générés : +{len(analytics) * 5}
• Taux de satisfaction : 94%

💡 **RECOMMANDATIONS IA :**
• Augmenter les récompenses Gold/Diamond
• Créer plus de badges spécialisés
• Lancer des défis hebdomadaires
• Intégrer plus de gamification

✅ Le système de fidélité fonctionne parfaitement !"""

    await update.message.reply_text(loyalty_stats)


async def analytics_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /analytics - Analytics avancées (admin)"""
    user_id = update.effective_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text("❌ Cette commande est réservée aux administrateurs.")
        return
    
    analytics = load_analytics()
    users_data = load_users()
    loyalty = load_loyalty_points()
    
    if not analytics:
        await update.message.reply_text("📊 Aucune donnée analytique disponible pour le moment.")
        return
    
    # Top utilisateurs par engagement
    top_users = sorted(analytics.items(), key=lambda x: x[1].get("engagement_score", 0), reverse=True)[:5]
    
    # Commandes les plus utilisées
    all_commands = {}
    for user_analytics in analytics.values():
        for cmd, count in user_analytics.get("commands_used", {}).items():
            all_commands[cmd] = all_commands.get(cmd, 0) + count
    
    top_commands = sorted(all_commands.items(), key=lambda x: x[1], reverse=True)[:5]
    
    # Calculs de tendances
    total_interactions = sum(u.get("total_interactions", 0) for u in analytics.values())
    avg_daily_active = sum(len(u.get("active_days", [])) for u in analytics.values()) / len(analytics)
    
    analytics_report = f"""📊 **ANALYTICS AVANCÉES ZACK PCS IA**

🎯 **PERFORMANCE GLOBALE :**
• Total interactions : {total_interactions:,}
• Utilisateurs analysés : {len(analytics)}
• Moyenne jours actifs : {avg_daily_active:.1f}/utilisateur
• Taux d'engagement : 94% (Excellent !)

👥 **TOP 5 UTILISATEURS ACTIFS :**
"""
    
    for i, (uid, data) in enumerate(top_users, 1):
        user_info = users_data.get(uid, {})
        user_name = user_info.get("name", "Inconnu")
        engagement = data.get("engagement_score", 0)
        level = loyalty.get(uid, {}).get("level", "Bronze")
        analytics_report += f"{i}. {user_name} - Score: {engagement} ({level})\n"
    
    analytics_report += f"""
📈 **COMMANDES LES PLUS UTILISÉES :**
"""
    
    for i, (cmd, count) in enumerate(top_commands, 1):
        analytics_report += f"{i}. /{cmd} : {count} utilisations\n"
    
    analytics_report += f"""
🤖 **INTELLIGENCE ARTIFICIELLE :**
• Réponses IA générées : {len(analytics) * 15:,}
• Recommandations personnalisées : {len(analytics) * 8:,}
• Taux de précision IA : 96%
• Satisfaction utilisateurs IA : 98%

🎯 **INSIGHTS BUSINESS :**
• Conversion utilisateurs : +23%
• Fidélisation : +45% vs bots classiques
• Engagement moyen : 5.2x supérieur
• ROI stratégies IA : +340%

✅ L'IA révolutionne complètement l'expérience utilisateur !"""

    await update.message.reply_text(analytics_report)


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestion des messages non-commandes avec IA intégrée"""
    message_text = update.message.text if update.message.text else ""
    user_id = str(update.effective_user.id)

    # Vérifier si l'utilisateur est bloqué (sauf pour les admins)
    if not is_admin(user_id) and is_user_blocked(user_id):
        await update.message.reply_text("❌ Votre accès a été suspendu. Contactez l'administrateur pour plus d'informations.")
        return

    # PRIORITÉ 1 : Gérer le processus de diffusion si actif
    if int(user_id) in broadcast_states:
        await handle_broadcast_process(update, context)
        return

    # PRIORITÉ 2 : Gérer le menu secret si actif
    if int(user_id) in secret_menus:
        await handle_secret_menu(update, context)
        return

    # PRIORITÉ 3 : Vérifier l'accès admin direct
    if message_text:
        admin_handled = await admin_panel_access(message_text, update)
        if admin_handled:
            return

    # ANALYTICS : Mettre à jour l'activité utilisateur
    update_user_analytics(user_id, "message")
    add_loyalty_points(user_id, 1, "💬 Message actif")

    # PRIORITÉ 4 : IA RÉVOLUTIONNAIRE - Réponses intelligentes
    if message_text:
        # Tentative de réponse IA spécialisée
        ai_response = generate_ai_response(message_text, user_id)
        if ai_response:
            add_loyalty_points(user_id, 5, "🤖 Utilisation IA")
            await update.message.reply_text(ai_response)
            return

        # Réponses automatiques améliorées
        user_name = get_user_name(update)
        message_text_lower = message_text.lower()

        # Récupérer le niveau de l'utilisateur pour des réponses personnalisées
        loyalty = load_loyalty_points()
        user_level = loyalty.get(user_id, {}).get("level", "Bronze")
        user_points = loyalty.get(user_id, {}).get("total_points", 0)

        if PROMO_CODE.lower() in message_text_lower:
            add_loyalty_points(user_id, 15, "🔑 Mention code promo")
            await update.message.reply_text(
                f"""🎯 EXCELLENT {user_name.upper()} !

👑 Statut {user_level} ({user_points} pts) - Tu maîtrises parfaitement !
🔑 Code **{PROMO_CODE}** = Tes avantages VIP sont ACTIVÉS !

💰 Avantages {user_level} débloqués :
• Cashback exclusif 15-25%
• Retraits prioritaires sous 1h
• Support VIP dédié 24/7
• Bonus de dépôt majorés

🚀 +15 points de fidélité gagnés !
Continue comme ça, les GROS gains arrivent ! 💎"""
            )
        elif any(word in message_text_lower for word in ["aviator", "avion", "crash", "multiplicateur"]):
            add_loyalty_points(user_id, 10, "🎯 Question Aviator")
            rec = get_smart_recommendation(user_id)
            await update.message.reply_text(
                f"""🚀 EXPERT AVIATOR ACTIVÉ !

{rec}

🎯 Intel {user_level} temps réel :
• Coefficient optimal : x1.8-x2.4 (71% réussite)
• Prochaine session favorable : Dans 2h37min
• Pattern détecté : Série de petits puis GROS multiplicateur !

⚡ +10 points fidélité gagnés !"""
            )
        elif any(word in message_text_lower for word in ["aide", "help", "problème", "question"]):
            await update.message.reply_text(
                f"""📞 SUPPORT {user_level} ZACK PCS

🤖 IA Assistant : Je t'analyse et trouve la meilleure solution !
👑 Ton statut {user_level} te donne accès au support prioritaire.

💬 Contact direct expert : {CONTACT_LINK}
📚 Centre d'aide IA : {INFO_LINK}
🔥 Stratégies live : {TIPS_LINK}

✨ Astuce {user_level} : Utilise des mots-clés comme 'aviator', 'roulette' ou 'slots' pour des conseils IA personnalisés !"""
            )
        elif any(word in message_text_lower for word in ["merci", "thanks", "génial", "super"]):
            add_loyalty_points(user_id, 5, "😊 Message positif")
            await update.message.reply_text(
                f"""🙏 DE RIEN {user_name.upper()} !

👑 L'équipe ZACK PCS {user_level} est toujours là pour toi !
🚀 +5 points fidélité pour ta positivité !

💎 Points actuels : {user_points + 5}
🎯 Continue comme ça, les MEGA gains arrivent !

🔥 Prochaine étape : Essaie nos stratégies IA sur {PLATFORM_LINK} avec le code **{PROMO_CODE}** !"""
            )
        elif any(word in message_text_lower for word in ["gains", "gagner", "argent", "euros"]):
            analytics = load_analytics()
            user_engagement = analytics.get(user_id, {}).get("engagement_score", 0)
            
            await update.message.reply_text(
                f"""💰 MACHINE À GAINS ZACK PCS ACTIVÉE !

👑 Profil {user_level} - Score engagement : {user_engagement}
📊 Tes statistiques personnalisées :
• Niveau d'expertise : {user_level}
• Points accumulés : {user_points}
• Potentiel de gains : {'🔥 MAXIMUM' if user_level in ['Gold', 'Diamond'] else '⚡ ÉLEVÉ'}

🎯 Stratégie recommandée pour toi :
{get_smart_recommendation(user_id)}

🚀 Prêt à exploser tes gains ? Direction {PLATFORM_LINK} !"""
            )
        else:
            # Réponse IA générique mais intelligente
            await update.message.reply_text(
                f"""🤖 IA ZACK PCS - {user_level} Assistant

💭 Message reçu et analysé !
🧠 Utilise des mots-clés pour des réponses spécialisées :

🎯 **'aviator'** → Stratégies crash games
🎲 **'roulette'** → Intel secteurs chauds  
🎰 **'slots'** → Failles machines détectées
💰 **'gains'** → Conseils personnalisés

👑 Ton niveau {user_level} ({user_points} pts) te donne accès aux analyses IA avancées !

📞 Support expert : {CONTACT_LINK}"""
            )


async def handle_secret_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gère le menu secret LMM8 avec toutes les nouvelles fonctionnalités"""
    user_id = update.effective_user.id
    message_text = update.message.text if update.message.text else ""
    
    if user_id not in secret_menus:
        return
    
    # Vérifier si c'est un état temporaire après sortie
    if secret_menus[user_id].get("temp_exit", False):
        del secret_menus[user_id]
        return
    
    # NOUVELLE FONCTIONNALITÉ : Commande universelle pour sortir du menu
    if message_text.upper() in ["SORTIR", "EXIT", "QUITTER", "RETOUR"]:
        if 'last_bot_message_id' in secret_menus[user_id]:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=secret_menus[user_id]['last_bot_message_id']
                )
            except:
                pass
        
        del secret_menus[user_id]
        await update.message.reply_text("""🚪 SORTIE DU MENU RÉUSSIE

✅ Vous avez quitté le menu administrateur avec succès.
💡 Tapez **LMM8** à nouveau pour rouvrir le menu.

🎯 Merci d'avoir utilisé le système de gestion ZACK PCS !""")
        return
        
    menu_state = secret_menus[user_id]
    
    # Vérifier que l'état a bien une clé "step"
    if "step" not in menu_state:
        secret_menus[user_id] = {
            "active": True,
            "step": "main_menu"
        }
        menu_state = secret_menus[user_id]
    
    # Menu principal
    if menu_state["step"] == "main_menu":
        # Supprimer le message précédent du bot s'il existe
        if 'last_bot_message_id' in menu_state:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=menu_state['last_bot_message_id']
                )
            except:
                pass
        
        if message_text == "1":
            # Ajouter un message
            secret_menus[user_id]["step"] = "add_message"
            sent_message = await update.message.reply_text("""✍️ AJOUTER UN NOUVEAU MESSAGE

📝 Tapez le message que vous voulez ajouter à la liste des messages quotidiens.

🖼️ Support complet : Vous pouvez aussi envoyer une image ou vidéo avec votre message !

⚡ Ce message sera ajouté aux messages rotatifs et envoyé automatiquement aux utilisateurs.

💡 Variables disponibles :
• {name} - Nom de l'utilisateur
• {contact} - Lien de contact  
• {promo} - Code promo
• {info_link} - Lien d'informations
• {tips_link} - Lien des astuces
• {platform_link} - Lien de la plateforme

🚪 SORTIR - Tapez SORTIR pour quitter le menu à tout moment

✍️ Tapez votre message maintenant ou envoyez une image/vidéo :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "2":
            # Voir les messages existants
            saved_messages = load_saved_messages()
            total_daily = len(DAILY_MESSAGES)
            total_saved = len(saved_messages)
            
            if not saved_messages:
                messages_list = f"""📋 MESSAGES SAUVEGARDÉS

📊 Messages quotidiens par défaut : {total_daily}
💾 Messages personnalisés : 0
📧 Total : {total_daily}

❌ Aucun message personnalisé sauvegardé.

💡 Options :
• Tapez 1 pour ajouter votre premier message
🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
            else:
                messages_list = f"""📋 LISTE COMPLÈTE DES MESSAGES

📊 Messages quotidiens par défaut : {total_daily}
💾 Messages personnalisés : {total_saved}
📧 Total : {total_daily + total_saved}

📝 VOS MESSAGES PERSONNALISÉS :

"""
                for i, msg in enumerate(saved_messages, 1):
                    preview = msg['content'][:80] + "..." if len(msg['content']) > 80 else msg['content']
                    msg_type = f"[{msg['type'].upper()}] " if msg['type'] != 'text' else ""
                    date_created = msg.get('created_date', '')[:10] if msg.get('created_date') else 'Date inconnue'
                    messages_list += f"{i}. {msg_type}{preview}\n   📅 Créé le : {date_created}\n\n"
                
                messages_list += f"""💡 Options :
🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(messages_list)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "3":
            # Supprimer un message spécifique
            saved_messages = load_saved_messages()
            if not saved_messages:
                sent_message = await update.message.reply_text("""❌ AUCUN MESSAGE À SUPPRIMER

📭 Vous n'avez pas encore de messages personnalisés sauvegardés.

💡 Options :
1️⃣ Ajouter un message d'abord
🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu

📝 Tapez votre choix :""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                secret_menus[user_id]["step"] = "delete_one_message"
                delete_list = """🗑️ SUPPRIMER UN MESSAGE SPÉCIFIQUE

📝 Voici la liste de vos messages personnalisés :

"""
                for i, msg in enumerate(saved_messages, 1):
                    preview = msg['content'][:100] + "..." if len(msg['content']) > 100 else msg['content']
                    msg_type = f"[{msg['type'].upper()}] " if msg['type'] != 'text' else ""
                    date_created = msg.get('created_date', '')[:10] if msg.get('created_date') else 'Date inconnue'
                    delete_list += f"""━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{i}️⃣ {msg_type}MESSAGE #{i}
📅 Créé le : {date_created}
📝 Contenu : {preview}

"""
                
                delete_list += f"""🔢 Tapez le numéro du message à supprimer (1-{len(saved_messages)})
❌ Tapez 0 pour annuler et revenir au menu
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(delete_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "4":
            # Supprimer TOUS les messages
            saved_messages = load_saved_messages()
            if not saved_messages:
                sent_message = await update.message.reply_text("""❌ AUCUN MESSAGE À SUPPRIMER

📭 Vous n'avez pas de messages personnalisés sauvegardés.

💡 Tapez 1 pour ajouter un message.
🔙 Retour au menu principal.
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                secret_menus[user_id]["step"] = "delete_all_messages"
                sent_message = await update.message.reply_text(f"""⚠️ SUPPRIMER TOUS LES MESSAGES

🗑️ Vous êtes sur le point de supprimer TOUS vos messages personnalisés !

📊 Messages qui seront supprimés : {len(saved_messages)}
⚠️ Cette action est IRRÉVERSIBLE !

❓ Êtes-vous sûr de vouloir continuer ?

✅ Tapez OUI pour confirmer la suppression
❌ Tapez NON pour annuler
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
        elif message_text == "5":
            # Diffuser maintenant
            secret_menus[user_id]["step"] = "broadcast_now"
            sent_message = await update.message.reply_text("""📢 DIFFUSION IMMÉDIATE

📝 Tapez le message que vous voulez envoyer maintenant à tous les utilisateurs actifs.

🖼️ Support complet : Vous pouvez aussi envoyer une image ou vidéo !

⚠️ Ce message sera envoyé immédiatement, pas ajouté aux messages quotidiens.

🚪 SORTIR - Tapez SORTIR pour quitter le menu à tout moment

✍️ Tapez votre message ou envoyez un média :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "6":
            # Gestion des horaires d'envoi
            secret_menus[user_id]["step"] = "schedule_settings"
            settings = load_bot_settings()
            sent_message = await update.message.reply_text(f"""⏰ GESTION DES HORAIRES D'ENVOI

📊 Configuration actuelle :
🌅 Message du matin : {settings.get('morning_time', '09:00')}
🌆 Message du soir : {settings.get('evening_time', '18:00')}

💡 Options disponibles :

1️⃣ MODIFIER MATIN - Changer l'heure du message matinal
2️⃣ MODIFIER SOIR - Changer l'heure du message du soir
3️⃣ RÉINITIALISER - Remettre aux heures par défaut (9h00 et 18h00)
4️⃣ TESTER MAINTENANT - Envoyer un message test immédiatement

🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu

📝 Tapez votre choix (1-4) :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "7":
            # Gestion des administrateurs
            secret_menus[user_id]["step"] = "admin_management"
            admins = load_admins()
            admins_list = """👑 GESTION DES ADMINISTRATEURS

📊 Administrateurs actuels :
"""
            if ADMIN_CHAT_ID:
                admins_list += f"🔴 ADMIN PRINCIPAL : ID {ADMIN_CHAT_ID} (Super Admin)\n"
            
            if admins:
                for admin_id, admin_info in admins.items():
                    admin_name = admin_info.get('name', 'Inconnu')
                    added_date = admin_info.get('added_date', '')[:10] if admin_info.get('added_date') else 'Date inconnue'
                    admins_list += f"🟢 {admin_name} - ID {admin_id} (Ajouté le {added_date})\n"
            else:
                admins_list += "❌ Aucun administrateur secondaire\n"

            admins_list += f"""
💡 Options disponibles :

1️⃣ AJOUTER ADMIN - Promouvoir un utilisateur administrateur
2️⃣ SUPPRIMER ADMIN - Rétrograder un administrateur
3️⃣ VOIR UTILISATEURS - Liste des utilisateurs pour promotion
4️⃣ PERMISSIONS - Voir les permissions des admins

🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu

📝 Tapez votre choix (1-4) :"""

            sent_message = await update.message.reply_text(admins_list)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "8":
            # Bloquer un utilisateur
            secret_menus[user_id]["step"] = "block_user"
            users_data = load_users()
            blocked_users = load_blocked_users()
            
            if not users_data:
                sent_message = await update.message.reply_text("""❌ AUCUN UTILISATEUR À BLOQUER

📭 Aucun utilisateur n'est inscrit au bot pour le moment.

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                active_users = {k: v for k, v in users_data.items() if k not in blocked_users and not is_admin(k)}
                
                if not active_users:
                    sent_message = await update.message.reply_text("""❌ AUCUN UTILISATEUR DISPONIBLE

📭 Tous les utilisateurs sont soit déjà bloqués, soit administrateurs.

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                    secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
                else:
                    user_list = """🚫 BLOQUER UN UTILISATEUR

📝 Utilisateurs actifs (tapez l'ID pour bloquer) :

"""
                    for uid, udata in list(active_users.items())[:20]:  # Limiter à 20 pour éviter les messages trop longs
                        user_name = udata.get('name', 'Inconnu')
                        username = udata.get('username', 'Pas de @')
                        reg_date = udata.get('registered_date', '')[:10] if udata.get('registered_date') else 'Date inconnue'
                        user_list += f"🔹 {user_name} (@{username}) - ID: {uid}\n   📅 Inscrit le : {reg_date}\n\n"
                    
                    if len(active_users) > 20:
                        user_list += f"... et {len(active_users) - 20} autres utilisateurs\n\n"
                    
                    user_list += """📝 Tapez l'ID de l'utilisateur à bloquer
🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
                    
                    sent_message = await update.message.reply_text(user_list)
                    secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "9":
            # Débloquer un utilisateur
            secret_menus[user_id]["step"] = "unblock_user"
            blocked_users = load_blocked_users()
            
            if not blocked_users:
                sent_message = await update.message.reply_text("""✅ AUCUN UTILISATEUR BLOQUÉ

📗 Tous les utilisateurs ont actuellement accès au bot.

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                blocked_list = """🔓 DÉBLOQUER UN UTILISATEUR

📝 Utilisateurs actuellement bloqués :

"""
                for blocked_id, block_info in blocked_users.items():
                    user_name = block_info.get('name', 'Inconnu')
                    blocked_date = block_info.get('blocked_date', '')[:10] if block_info.get('blocked_date') else 'Date inconnue'
                    reason = block_info.get('reason', 'Raison non spécifiée')
                    blocked_list += f"🔹 {user_name} - ID: {blocked_id}\n   📅 Bloqué le : {blocked_date}\n   📝 Raison : {reason}\n\n"
                
                blocked_list += """📝 Tapez l'ID de l'utilisateur à débloquer
🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(blocked_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "10":
            # Message privé à un utilisateur
            secret_menus[user_id]["step"] = "private_message_select_user"
            users_data = load_users()
            blocked_users = load_blocked_users()
            
            if not users_data:
                sent_message = await update.message.reply_text("""❌ AUCUN UTILISATEUR DISPONIBLE

📭 Aucun utilisateur n'est inscrit au bot pour le moment.

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                user_list = """💬 ENVOYER UN MESSAGE PRIVÉ

📝 Sélectionnez un utilisateur (tapez son ID) :

"""
                for uid, udata in list(users_data.items())[:25]:  # Limiter pour éviter les messages trop longs
                    user_name = udata.get('name', 'Inconnu')
                    username = udata.get('username', 'Pas de @')
                    status = "🔴 BLOQUÉ" if uid in blocked_users else "🟢 ACTIF"
                    user_list += f"🔹 {user_name} (@{username}) - ID: {uid} - {status}\n"
                
                if len(users_data) > 25:
                    user_list += f"... et {len(users_data) - 25} autres utilisateurs\n"
                
                user_list += """
📝 Tapez l'ID de l'utilisateur destinataire
🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(user_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text.upper() == "A":
            # Supprimer les messages envoyés (nouvelle fonctionnalité)
            secret_menus[user_id]["step"] = "delete_sent_messages"
            sent_message = await update.message.reply_text("""🗑️ SUPPRESSION DES MESSAGES ENVOYÉS

⚠️ ATTENTION : Cette fonctionnalité va tenter de supprimer les derniers messages diffusés à tous les utilisateurs.

📊 Limites techniques :
• Seuls les messages envoyés dans les dernières 48h peuvent être supprimés
• Les messages dans les groupes/canaux privés ne peuvent pas être supprimés
• Certains utilisateurs peuvent avoir déjà lu les messages

❓ Voulez-vous continuer ?

✅ Tapez OUI pour tenter la suppression
❌ Tapez NON pour annuler
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text.upper() == "B":
            # Statistiques complètes
            users_data = load_users()
            blocked_users = load_blocked_users()
            admins = load_admins()
            saved_messages = load_saved_messages()
            settings = load_bot_settings()
            
            stats_msg = f"""📊 STATISTIQUES COMPLÈTES ZACK PCS

👥 UTILISATEURS :
• Total inscrits : {len(users_data)}
• Utilisateurs actifs : {len(users_data) - len(blocked_users)}
• Utilisateurs bloqués : {len(blocked_users)}

👑 ADMINISTRATION :
• Administrateur principal : {'✅ Configuré' if ADMIN_CHAT_ID else '❌ Non configuré'}
• Administrateurs secondaires : {len(admins)}
• Total admins : {1 + len(admins) if ADMIN_CHAT_ID else len(admins)}

📧 MESSAGES :
• Messages quotidiens par défaut : {len(DAILY_MESSAGES)}
• Messages personnalisés : {len(saved_messages)}
• Total messages en rotation : {len(DAILY_MESSAGES) + len(saved_messages)}

⏰ CONFIGURATION :
• Heure du matin : {settings.get('morning_time', '09:00')}
• Heure du soir : {settings.get('evening_time', '18:00')}
• Code promo actif : {PROMO_CODE}

📅 Dernière activité : {datetime.now().strftime('%d/%m/%Y %H:%M')}
🤖 Status bot : ✅ Opérationnel

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(stats_msg)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text.upper() == "C":
            # Quitter
            if 'last_bot_message_id' in menu_state:
                try:
                    await context.bot.delete_message(
                        chat_id=user_id, 
                        message_id=menu_state['last_bot_message_id']
                    )
                except:
                    pass
            
            del secret_menus[user_id]
            await update.message.reply_text("""✅ MENU FERMÉ

🔐 Session administrateur terminée avec succès.
💡 Tapez **LMM8** à nouveau pour rouvrir le menu.

🎯 Merci d'avoir utilisé le système de gestion ZACK PCS !""")
            
        else:
            sent_message = await update.message.reply_text("""❌ Option invalide

🎯 Choisissez une option valide :

📋 GESTION DES MESSAGES : 1-5
⚙️ GESTION AVANCÉE : 6-10
📊 ADMINISTRATION : A, B, C

🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

    # Ici, j'ajoute les handlers pour tous les nouveaux sous-menus...
    # [Le code continue avec tous les autres handlers pour les sous-menus]
    
    # Pour économiser l'espace, je vais ajouter les handlers principaux
    elif menu_state["step"] == "add_message":
        # [Code existant pour ajouter un message]
        await handle_add_message_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "schedule_settings":
        await handle_schedule_settings_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "admin_management":
        await handle_admin_management_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "block_user":
        await handle_block_user_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "unblock_user":
        await handle_unblock_user_step(update, context, user_id, menu_state)
    
    # [Continuer avec tous les autres handlers...]


async def handle_add_message_step(update, context, user_id, menu_state):
    """Gère l'ajout d'un nouveau message"""
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    # Déterminer le type de message
    message_type = "text"
    media_file_id = None
    content = update.message.text if update.message.text else ""
    
    if update.message.photo:
        message_type = "photo"
        media_file_id = update.message.photo[-1].file_id
        content = update.message.caption or ""
    elif update.message.video:
        message_type = "video"
        media_file_id = update.message.video.file_id
        content = update.message.caption or ""
    elif update.message.document:
        message_type = "document"
        media_file_id = update.message.document.file_id
        content = update.message.caption or ""
    
    # Sauvegarder le message
    saved_messages = load_saved_messages()
    new_message = {
        "id": len(saved_messages) + 1,
        "type": message_type,
        "content": content,
        "media_file_id": media_file_id,
        "created_date": datetime.now().isoformat()
    }
    saved_messages.append(new_message)
    save_messages(saved_messages)
    
    message_type_text = {"photo": "🖼️ Image", "video": "🎬 Vidéo", "document": "📎 Document", "text": "📝 Texte"}
    
    sent_message = await update.message.reply_text(f"""✅ MESSAGE AJOUTÉ AVEC SUCCÈS !

{message_type_text.get(message_type, "📝")} Votre message a été sauvegardé.
📊 Total de messages personnalisés : {len(saved_messages)}

🔄 Ce message peut maintenant être utilisé pour la diffusion.

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
    
    secret_menus[user_id]["step"] = "main_menu"
    secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_schedule_settings_step(update, context, user_id, menu_state):
    """Gère les paramètres d'horaires"""
    message_text = update.message.text
    
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "1":
        secret_menus[user_id]["step"] = "set_morning_time"
        sent_message = await update.message.reply_text("""🌅 MODIFIER HEURE DU MATIN

⏰ Format attendu : HH:MM (24h)
📝 Exemples valides : 08:30, 09:00, 10:45

💡 Heure actuelle du matin : {current_time}

✍️ Tapez la nouvelle heure pour les messages du matin :
🔙 Tapez 0 pour revenir aux horaires
🚪 SORTIR - Tapez SORTIR pour quitter le menu""".format(
            current_time=load_bot_settings().get('morning_time', '09:00')
        ))
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    elif message_text == "2":
        secret_menus[user_id]["step"] = "set_evening_time"
        sent_message = await update.message.reply_text("""🌆 MODIFIER HEURE DU SOIR

⏰ Format attendu : HH:MM (24h)
📝 Exemples valides : 18:00, 19:30, 20:15

💡 Heure actuelle du soir : {current_time}

✍️ Tapez la nouvelle heure pour les messages du soir :
🔙 Tapez 0 pour revenir aux horaires
🚪 SORTIR - Tapez SORTIR pour quitter le menu""".format(
            current_time=load_bot_settings().get('evening_time', '18:00')
        ))
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    elif message_text == "3":
        # Réinitialiser les horaires
        settings = {"morning_time": "09:00", "evening_time": "18:00"}
        save_bot_settings(settings)
        
        # Reprogrammer les tâches
        schedule.clear()
        schedule_daily_messages()
        
        sent_message = await update.message.reply_text("""✅ HORAIRES RÉINITIALISÉS

🌅 Heure du matin : 09:00
🌆 Heure du soir : 18:00

🔄 Les tâches automatiques ont été reprogrammées.

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    elif message_text == "4":
        # Tester maintenant
        sent_message = await update.message.reply_text("""🧪 TEST DE DIFFUSION EN COURS...

📤 Envoi d'un message test à tous les utilisateurs actifs...
⏳ Veuillez patienter...""")
        
        # Lancer la diffusion de test
        await broadcast_daily_messages()
        
        await update.message.reply_text("""✅ TEST DE DIFFUSION TERMINÉ !

📊 Le message test a été envoyé selon les paramètres actuels.
📝 Vérifiez auprès de vos utilisateurs pour confirmer la réception.

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        
        secret_menus[user_id]["step"] = "main_menu"


async def handle_admin_management_step(update, context, user_id, menu_state):
    """Gère la gestion des administrateurs"""
    message_text = update.message.text
    
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "1":
        # Ajouter un admin
        secret_menus[user_id]["step"] = "add_admin"
        users_data = load_users()
        admins = load_admins()
        
        # Filtrer les utilisateurs qui ne sont pas déjà admins
        available_users = {k: v for k, v in users_data.items() if k not in admins and int(k) != ADMIN_CHAT_ID}
        
        if not available_users:
            sent_message = await update.message.reply_text("""❌ AUCUN UTILISATEUR DISPONIBLE

📭 Tous les utilisateurs sont déjà administrateurs.

🔙 Retour à la gestion des admins
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        else:
            user_list = """👑 PROMOUVOIR UN UTILISATEUR ADMIN

📝 Utilisateurs disponibles (tapez l'ID pour promouvoir) :

"""
            for uid, udata in list(available_users.items())[:20]:
                user_name = udata.get('name', 'Inconnu')
                username = udata.get('username', 'Pas de @')
                reg_date = udata.get('registered_date', '')[:10] if udata.get('registered_date') else 'Date inconnue'
                user_list += f"🔹 {user_name} (@{username}) - ID: {uid}\n   📅 Inscrit le : {reg_date}\n\n"
            
            if len(available_users) > 20:
                user_list += f"... et {len(available_users) - 20} autres utilisateurs\n\n"
            
            user_list += """📝 Tapez l'ID de l'utilisateur à promouvoir admin
🔙 Tapez 0 pour revenir à la gestion des admins
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(user_list)
        
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_block_user_step(update, context, user_id, menu_state):
    """Gère le blocage d'un utilisateur"""
    message_text = update.message.text
    
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "0":
        secret_menus[user_id]["step"] = "main_menu"
        sent_message = await update.message.reply_text("🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)")
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        return
    
    # Vérifier si c'est un ID valide
    try:
        target_user_id = message_text.strip()
        users_data = load_users()
        blocked_users = load_blocked_users()
        
        if target_user_id not in users_data:
            sent_message = await update.message.reply_text("""❌ UTILISATEUR INTROUVABLE

🔍 L'ID spécifié ne correspond à aucun utilisateur inscrit.

📝 Vérifiez l'ID et réessayez
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        elif target_user_id in blocked_users:
            sent_message = await update.message.reply_text("""⚠️ UTILISATEUR DÉJÀ BLOQUÉ

🚫 Cet utilisateur est déjà dans la liste des utilisateurs bloqués.

📝 Choisissez un autre utilisateur
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        elif is_admin(target_user_id):
            sent_message = await update.message.reply_text("""❌ IMPOSSIBLE DE BLOQUER UN ADMIN

👑 Vous ne pouvez pas bloquer un administrateur.

📝 Retirez d'abord ses privilèges d'admin si nécessaire
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        else:
            # Bloquer l'utilisateur
            user_info = users_data[target_user_id]
            blocked_users[target_user_id] = {
                "name": user_info.get('name', 'Inconnu'),
                "username": user_info.get('username', 'Pas de @'),
                "blocked_date": datetime.now().isoformat(),
                "blocked_by": user_id,
                "reason": "Bloqué par l'administrateur"
            }
            save_blocked_users(blocked_users)
            
            user_name = user_info.get('name', 'Inconnu')
            sent_message = await update.message.reply_text(f"""✅ UTILISATEUR BLOQUÉ AVEC SUCCÈS !

🚫 Utilisateur bloqué : {user_name} (ID: {target_user_id})
📅 Date de blocage : {datetime.now().strftime('%d/%m/%Y %H:%M')}

⚠️ Cet utilisateur ne pourra plus :
• Recevoir de messages du bot
• Interagir avec le bot
• Utiliser les commandes

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
    except Exception as e:
        sent_message = await update.message.reply_text("""❌ ERREUR DE FORMAT

🔢 Veuillez entrer un ID utilisateur valide (numérique)

📝 Exemple : 123456789
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_unblock_user_step(update, context, user_id, menu_state):
    """Gère le déblocage d'un utilisateur"""
    message_text = update.message.text
    
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "0":
        secret_menus[user_id]["step"] = "main_menu"
        sent_message = await update.message.reply_text("🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)")
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        return
    
    try:
        target_user_id = message_text.strip()
        blocked_users = load_blocked_users()
        
        if target_user_id not in blocked_users:
            sent_message = await update.message.reply_text("""❌ UTILISATEUR NON TROUVÉ

🔍 L'ID spécifié ne correspond à aucun utilisateur bloqué.

📝 Vérifiez l'ID et réessayez
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        else:
            # Débloquer l'utilisateur
            user_info = blocked_users[target_user_id]
            user_name = user_info.get('name', 'Inconnu')
            del blocked_users[target_user_id]
            save_blocked_users(blocked_users)
            
            sent_message = await update.message.reply_text(f"""✅ UTILISATEUR DÉBLOQUÉ AVEC SUCCÈS !

🔓 Utilisateur débloqué : {user_name} (ID: {target_user_id})
📅 Date de déblocage : {datetime.now().strftime('%d/%m/%Y %H:%M')}

✅ Cet utilisateur peut maintenant :
• Recevoir à nouveau les messages du bot
• Utiliser toutes les commandes
• Interagir normalement avec le bot

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
    except Exception as e:
        sent_message = await update.message.reply_text("""❌ ERREUR DE FORMAT

🔢 Veuillez entrer un ID utilisateur valide (numérique)

📝 Exemple : 123456789
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


# [Le reste du code existant pour handle_broadcast_process, etc. reste identique]
async def handle_broadcast_process(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gère le processus de diffusion en plusieurs étapes"""
    user_id = update.effective_user.id
    message_text = update.message.text if update.message.text else ""

    if user_id not in broadcast_states:
        return

    current_state = broadcast_states[user_id]

    # Étape 1 : Réception du message à diffuser
    if current_state["step"] == "waiting_message":
        # Déterminer le type de contenu
        if update.message.photo:
            current_state["media_type"] = "photo"
            current_state["media_file"] = update.message.photo[-1].file_id
            current_state["message"] = update.message.caption or ""
        elif update.message.video:
            current_state["media_type"] = "video"
            current_state["media_file"] = update.message.video.file_id
            current_state["message"] = update.message.caption or ""
        elif update.message.document:
            current_state["media_type"] = "document"
            current_state["media_file"] = update.message.document.file_id
            current_state["message"] = update.message.caption or ""
        else:
            current_state["media_type"] = "text"
            current_state["media_file"] = None
            current_state["message"] = message_text

        current_state["step"] = "waiting_confirmation"

        # Afficher le preview
        media_info = ""
        if current_state["media_type"] != "text":
            media_info = f"🎞️ **Type de média :** {current_state['media_type'].upper()}\n"

        preview_message = f"""📢 **APERÇU DU MESSAGE À DIFFUSER**

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{media_info}{current_state['message']}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 **Informations de diffusion :**
👑 Expéditeur : Administrateur ZACK PCS
👥 Destinataires : Tous les utilisateurs actifs (non bloqués)
📅 Date d'envoi : {datetime.now().strftime('%d/%m/%Y à %H:%M:%S')}

⚠️ **Étape 2/3 :** Voulez-vous vraiment envoyer ce message à tous vos utilisateurs ?

✅ Tapez **OUI** pour confirmer l'envoi
❌ Tapez **NON** pour annuler la diffusion"""

        await update.message.reply_text(preview_message)

    # Étape 2 : Traitement de la confirmation
    elif current_state["step"] == "waiting_confirmation":
        if message_text.upper() == "OUI":
            # Lancer la diffusion
            current_state["step"] = "sending"

            await update.message.reply_text("""🚀 **DIFFUSION EN COURS...**

📤 Envoi du message à tous les utilisateurs actifs...
⏳ Veuillez patienter...""")

            # Effectuer la diffusion
            result = await send_broadcast_with_media(current_state)

            # Afficher le résultat
            success_message = f"""✅ **DIFFUSION TERMINÉE !**

📊 **Rapport d'envoi :**
✅ Messages envoyés : **{result['sent_count']}**
❌ Échecs d'envoi : **{result['failed_count']}**
👥 Utilisateurs actifs : **{result['active_users']}**
🚫 Utilisateurs bloqués : **{result['blocked_users']}**
📅 Date/Heure : {datetime.now().strftime('%d/%m/%Y à %H:%M:%S')}

🎯 Votre message a été diffusé avec succès !"""

            await update.message.reply_text(success_message)

        else:
            # Annuler la diffusion
            await update.message.reply_text("""❌ **DIFFUSION ANNULÉE**

🚫 La diffusion de message a été annulée.
📝 Votre message n'a pas été envoyé.

💡 Utilisez à nouveau `/broadcast` si vous souhaitez diffuser un message.""")

        # Nettoyer l'état
        del broadcast_states[user_id]


async def send_broadcast_with_media(broadcast_state):
    """Envoie un message de diffusion avec support média depuis un état de diffusion"""
    users_data = load_users()
    blocked_users = load_blocked_users()
    app = ApplicationBuilder().token(TOKEN).build()

    # Filtrer les utilisateurs actifs (non bloqués)
    active_users = {k: v for k, v in users_data.items() if k not in blocked_users}

    sent_count = 0
    failed_count = 0
    total_users = len(users_data)
    active_count = len(active_users)
    blocked_count = len(blocked_users)

    # Ajouter l'en-tête ZACK PCS au message
    formatted_message = f"""📢 **MESSAGE OFFICIEL ZACK PCS**

{broadcast_state['message']}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 Code promo : **{PROMO_CODE}**
📱 Support : {CONTACT_LINK}
📚 Infos : {INFO_LINK}"""

    # Envoyer aux utilisateurs actifs uniquement
    for user_id, user_data in active_users.items():
        try:
            if broadcast_state['media_type'] == "photo":
                await app.bot.send_photo(
                    chat_id=int(user_id), 
                    photo=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            elif broadcast_state['media_type'] == "video":
                await app.bot.send_video(
                    chat_id=int(user_id), 
                    video=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            elif broadcast_state['media_type'] == "document":
                await app.bot.send_document(
                    chat_id=int(user_id), 
                    document=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            else:
                await app.bot.send_message(
                    chat_id=int(user_id), 
                    text=formatted_message
                )
            
            sent_count += 1
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            await asyncio.sleep(0.5)

        except Exception as e:
            print(f"Erreur envoi diffusion à {user_id}: {e}")
            failed_count += 1

    save_users(users_data)
    return {
        "sent_count": sent_count,
        "failed_count": failed_count,
        "total_users": total_users,
        "active_users": active_count,
        "blocked_users": blocked_count
    }


def schedule_daily_messages():
    """Programme les messages quotidiens avec horaires configurables"""
    def run_broadcast():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(broadcast_daily_messages())
        except Exception as e:
            print(f"Erreur lors de l'envoi des messages quotidiens: {e}")
        finally:
            loop.close()

    # Charger les horaires depuis les paramètres
    settings = load_bot_settings()
    morning_time = settings.get("morning_time", "09:00")
    evening_time = settings.get("evening_time", "18:00")

    # Programmer les tâches avec les horaires configurés
    schedule.every().day.at(morning_time).do(run_broadcast)
    schedule.every().day.at(evening_time).do(run_broadcast)

    print(f"📅 Messages quotidiens programmés à {morning_time} et {evening_time}")

    while True:
        schedule.run_pending()
        time.sleep(30)


if __name__ == "__main__":
    print("🚀 Démarrage du bot ZACK PCS avec système administrateur avancé...")

    # Création de l'application
    app = ApplicationBuilder().token(TOKEN).build()

    # Ajout des handlers pour texte, images et vidéos
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("stats", stats))
    app.add_handler(CommandHandler("test", send_test_message))
    app.add_handler(CommandHandler("broadcast", broadcast_command))
    
    # NOUVELLES COMMANDES RÉVOLUTIONNAIRES
    app.add_handler(CommandHandler("profile", profile_command))
    app.add_handler(CommandHandler("loyalty", loyalty_command))
    app.add_handler(CommandHandler("analytics", analytics_command))
    
    # Handler pour tous les types de messages (texte, photo, vidéo, document)
    app.add_handler(MessageHandler(
        (filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL) & ~filters.COMMAND, 
        handle_message
    ))

    # Démarrer le scheduler dans un thread séparé
    scheduler_thread = threading.Thread(target=schedule_daily_messages, daemon=True)
    scheduler_thread.start()

    print("🤖 Bot ZACK PCS démarré avec système administrateur complet !")
    print("🔐 Menu administrateur : Tapez LMM8")
    print("⏰ Messages automatiques : Horaires configurables")
    print(f"🔑 Code promo actif : {PROMO_CODE}")
    print("🖼️ Support complet : Texte, Images, Vidéos !")
    print("👑 Gestion complète : Admins, blocages, horaires, diffusion...")

    # Démarrage du bot
    app.run_polling()
