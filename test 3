
import json
import os
import asyncio
import schedule
import time
from datetime import datetime, timedelta
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
import threading

TOKEN = "7997467039:AAF86L8qutp9OzG8K5Hfwh1LG4cePd6BPas"
PROMO_CODE = "SANA33"
CONTACT_LINK = "https://t.me/ZACKCASH22"
DATA_FILE = "users.json"
MESSAGES_FILE = "saved_messages.json"
ADMINS_FILE = "admins.json"
BLOCKED_USERS_FILE = "blocked_users.json"
SETTINGS_FILE = "bot_settings.json"
ADMIN_CHAT_ID = None  # Sera défini automatiquement lors de la première connexion admin

# Système de gestion d'états pour la diffusion
broadcast_states = {}

# Liens officiels ZACK PCS
INFO_LINK = "https://bot9082.github.io/Info-/"
TIPS_LINK = "https://bot9082.github.io/ZACK-CASH/"
PLATFORM_LINK = "https://1wlucb.life/casino/list/4?p=169j"

# Messages rotatifs personnalisés ZACK PCS
DAILY_MESSAGES = [
    """Hey {name} !  

📌 ZACK PCS - Stratégies Casino Officielles 🎯

🎰 Nouvelle astuce Aviator détectée aujourd'hui !
⏰ Heures favorables : 14h-16h et 20h-22h
🔥 Faille sur roulette européenne confirmée !
💎 Machines à sous : patterns identifiés sur Book of Ra

📚 Infos complètes : {info_link}
📄 Astuces du jour : {tips_link}
🎲 Plateforme recommandée 1win : {platform_link}

🔑 Code promo : **{promo}** pour activer tous les avantages !
💬 Support ZACK : {contact}""",

    """Salut {name} !  

🎯 ZACK PCS - Mise à jour stratégies 🚀

💰 Gains observés : +850€ en 3h avec nos méthodes !
⚡ Nouveau schéma détecté sur Crazy Time !
🎲 Roulette : mise sur secteurs chauds = 73% réussite
🎰 Aviator : coefficient optimal entre x1.4 et x2.1

📖 Guide complet : {info_link}
🔥 Dernières astuces : {tips_link}
🏆 Inscription 1win : {platform_link}

✅ Code **{promo}** = retraits rapides + bonus exclusifs
📱 Contact direct : {contact}""",

    """Hey {name} !  

🔥 ZACK PCS - Alertes Failles Casino ⚠️

🎰 URGENT : Faille Sweet Bonanza active jusqu'à minuit !
💎 Machines progressives : jackpots près d'exploser !
🎲 Roulette live : dealer favorable identifié salle 3
⭐ Aviator : algorithme prévisible entre 18h-20h

📋 Procédures détaillées : {info_link}
💯 Stratégies actualisées : {tips_link}
🎯 Plateforme sécurisée : {platform_link}

🔑 OBLIGATOIRE : Code **{promo}** pour accès complet
📞 Aide personnalisée : {contact}""",

    """Bonjour {name} !  

💸 ZACK PCS - Résultats Exceptionnels 📊

🚀 Record battu : +1,200€ en une session !
🎰 Aviator : 9 gains consécutifs avec notre timing
🔥 Blackjack live : stratégie optimisée = 68% victoires
💎 Slots volatiles : moments idéaux pour jouer gros

📚 Méthodes complètes : {info_link}
⚡ Tips actualisés : {tips_link}
🏅 Compte optimisé 1win : {platform_link}

✨ Code **{promo}** = avantages VIP instantanés
💬 Questions ? Écris : {contact}""",

    """Coucou {name} !  

⭐ ZACK PCS - Opportunités Limitées ⏳

🎯 DERNIÈRES 6H : Faille mega jackpot disponible !
💰 Gains moyens constatés : +650€/jour avec nos tips
🎲 Roulette française : série rouge/noir prévisible
🎰 Gates of Olympus : multiplicateurs x500 fréquents

📖 Accès formations : {info_link}
🔥 Astuces temps réel : {tips_link}
🎪 Interface optimale : {platform_link}

🔑 Code magique **{promo}** pour débloquer tout
📲 Support expert : {contact}""",

    """Bonsoir {name} ! 🌙

🎲 ZACK PCS - Session Nocturne Spéciale 
🦉 Les nuits sont les plus rentables sur 1win !
🎰 Aviator : moins de concurrence = plus de gains
💰 Roulette after midnight : tendances prévisibles
🔥 Bonus nocturnes jusqu'à +200% disponibles !

📊 Stats prouvées : +40% gains de 22h à 2h
⚡ Multiplicateurs fréquents détectés
🎯 Jackpots progressifs : seuils critiques atteints

📚 Guide nocturne : {info_link}
🔥 Stratégies nuit : {tips_link}
🌙 Session optimale : {platform_link}

🔑 Code nuit **{promo}** = bonus supplémentaires
💬 Support 24h/7j : {contact}""",

    """Hello {name} ! 👋

🚨 ZACK PCS - Alerte Gains Exceptionnels 
💥 BREAKING : Nouveau record établi +2,400€ !
🎰 Technique secrète révélée aujourd'hui uniquement
🔥 5 utilisateurs ont dépassé 1000€ cette semaine
⚡ Pattern exceptionnel découvert sur Plinko

🎯 Résultats cette semaine :
• Aviator : 89% de réussite
• Roulette : 76% sur nos secteurs
• Slots : x1000+ atteints 3 fois

📖 Méthode complète : {info_link}
🔥 Techniques avancées : {tips_link}
🏆 Plateforme premium : {platform_link}

🔑 Code VIP **{promo}** = accès prioritaire
📞 Coaching perso : {contact}""",

    """Yo {name} ! 🔥

⚡ ZACK PCS - Flash Info Casino 
🎯 URGENT : Maintenance 1win prévue demain 14h !
💰 Profitez maintenant avant l'interruption
🎰 Aviator : coefficient x25 observé 3 fois aujourd'hui  
🔥 Sweet Bonanza : free spins en masse détectés

⏰ Créneaux optimaux restants :
• 16h-18h : Roulette européenne  
• 19h-21h : Machines volatiles
• 22h-00h : Aviator premium

📚 Stratégies flash : {info_link}
⚡ Tips minute : {tips_link}
🎲 Accès direct : {platform_link}

🔑 Code flash **{promo}** = bonus immédiat
💬 Urgence ? Contacte : {contact}"""
]


def load_users():
    """Charge les utilisateurs depuis le fichier JSON"""
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_users(users_data):
    """Sauvegarde les utilisateurs dans le fichier JSON"""
    with open(DATA_FILE, 'w', encoding='utf-8') as f:
        json.dump(users_data, f, ensure_ascii=False, indent=2)


def load_saved_messages():
    """Charge les messages sauvegardés depuis le fichier JSON"""
    if os.path.exists(MESSAGES_FILE):
        try:
            with open(MESSAGES_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return []
    return []


def save_messages(messages_data):
    """Sauvegarde les messages dans le fichier JSON"""
    with open(MESSAGES_FILE, 'w', encoding='utf-8') as f:
        json.dump(messages_data, f, ensure_ascii=False, indent=2)


def load_admins():
    """Charge les administrateurs depuis le fichier JSON"""
    if os.path.exists(ADMINS_FILE):
        try:
            with open(ADMINS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_admins(admins_data):
    """Sauvegarde les administrateurs dans le fichier JSON"""
    with open(ADMINS_FILE, 'w', encoding='utf-8') as f:
        json.dump(admins_data, f, ensure_ascii=False, indent=2)


def load_blocked_users():
    """Charge les utilisateurs bloqués depuis le fichier JSON"""
    if os.path.exists(BLOCKED_USERS_FILE):
        try:
            with open(BLOCKED_USERS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


def save_blocked_users(blocked_data):
    """Sauvegarde les utilisateurs bloqués dans le fichier JSON"""
    with open(BLOCKED_USERS_FILE, 'w', encoding='utf-8') as f:
        json.dump(blocked_data, f, ensure_ascii=False, indent=2)


def load_bot_settings():
    """Charge les paramètres du bot depuis le fichier JSON"""
    if os.path.exists(SETTINGS_FILE):
        try:
            with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {"morning_time": "09:00", "evening_time": "18:00"}
    return {"morning_time": "09:00", "evening_time": "18:00"}


def save_bot_settings(settings_data):
    """Sauvegarde les paramètres du bot dans le fichier JSON"""
    with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
        json.dump(settings_data, f, ensure_ascii=False, indent=2)


def is_admin(user_id):
    """Vérifie si un utilisateur est administrateur"""
    global ADMIN_CHAT_ID
    if ADMIN_CHAT_ID and user_id == ADMIN_CHAT_ID:
        return True
    
    admins = load_admins()
    return str(user_id) in admins


def is_user_blocked(user_id):
    """Vérifie si un utilisateur est bloqué"""
    blocked_users = load_blocked_users()
    return str(user_id) in blocked_users


def get_user_name(update: Update):
    """Récupère le nom/pseudo de l'utilisateur"""
    user = update.effective_user
    if user.first_name:
        return user.first_name
    elif user.username:
        return user.username
    else:
        return "ami"


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /start - Accueille et enregistre l'utilisateur"""
    user_id = str(update.effective_user.id)
    user_name = get_user_name(update)

    # Vérifier si l'utilisateur est bloqué
    if is_user_blocked(user_id):
        await update.message.reply_text("❌ Votre accès a été suspendu. Contactez l'administrateur pour plus d'informations.")
        return

    # Charger les données existantes
    users_data = load_users()

    # Ajouter/mettre à jour l'utilisateur
    users_data[user_id] = {
        "name": user_name,
        "username": update.effective_user.username,
        "registered_date": datetime.now().isoformat(),
        "last_message": None
    }

    # Sauvegarder
    save_users(users_data)

    welcome_message = f"""🎯 BIENVENUE {user_name.upper()} DANS L'ÉLITE ZACK PCS !

🔥 Tu viens de rejoindre le cercle privé des stratégies casino les plus rentables :

💰 GAINS QUOTIDIENS OBSERVÉS :
• Aviator : +450€ à +1,200€ par session
• Roulette Live : 73% de réussite sur nos secteurs
• Machines à sous : Multiplicateurs x500+ fréquents
• Blackjack VIP : Stratégies optimisées = 68% victoires

⚡ ACCÈS IMMÉDIAT À :
🎲 Failles détectées en temps réel
📊 Heures favorables calculées par IA
🎯 Patterns exclusifs sur 1win Casino
🔍 Alertes multiplicateurs exceptionnels

📚 Ressources VIP : {INFO_LINK}
🔥 Astuces temps réel : {TIPS_LINK}
🏆 Plateforme premium : {PLATFORM_LINK}

🔑 Code magique : {PROMO_CODE} (activation instantanée)
💬 Support expert 24/7 : {CONTACT_LINK}

🚨 ATTENTION : Nos méthodes ont permis +15,000€ de gains cette semaine !

✅ Messages personnalisés activés - Prépare-toi à exploser tes gains !"""

    await update.message.reply_text(welcome_message)


async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /stats - Affiche les statistiques"""
    users_data = load_users()
    saved_messages = load_saved_messages()
    total_users = len(users_data)
    total_saved_messages = len(saved_messages)

    stats_message = f"""📊 **Statistiques du bot :**

👥 Total d'utilisateurs inscrits : **{total_users}**
📧 Messages sauvegardés : **{total_saved_messages}**
🔑 Code promo actif : **{PROMO_CODE}**
📅 Dernière mise à jour : {datetime.now().strftime('%d/%m/%Y %H:%M')}"""

    await update.message.reply_text(stats_message)


async def broadcast_daily_messages():
    """Envoie les messages quotidiens à tous les utilisateurs"""
    global ADMIN_CHAT_ID

    users_data = load_users()
    blocked_users = load_blocked_users()

    # Filtrer les utilisateurs bloqués
    active_users = {k: v for k, v in users_data.items() if k not in blocked_users}

    # Choisir un message du jour (rotation basée sur le jour de l'année)
    day_of_year = datetime.now().timetuple().tm_yday
    message_template = DAILY_MESSAGES[day_of_year % len(DAILY_MESSAGES)]

    # Créer l'application pour envoyer des messages
    app = ApplicationBuilder().token(TOKEN).build()

    sent_count = 0

    # Si pas d'utilisateurs ET que l'admin est connecté, envoyer un message test
    if not active_users and ADMIN_CHAT_ID is not None:
        print("Aucun utilisateur actif, envoi d'un message test à l'admin")
        try:
            test_message = f"""🧪 MESSAGE TEST ZACK PCS

👋 Salut Admin ! Voici un exemple de message quotidien :

{message_template.format(
                name="Admin", 
                contact=CONTACT_LINK, 
                promo=PROMO_CODE,
                info_link=INFO_LINK,
                tips_link=TIPS_LINK,
                platform_link=PLATFORM_LINK
            )}

✅ Le système de messages automatiques fonctionne parfaitement !
📊 Utilisateurs actifs : {len(active_users)} sur {len(users_data)} total"""

            await app.bot.send_message(chat_id=int(ADMIN_CHAT_ID), text=test_message)
            print("✅ Message test envoyé à l'admin")
            return
        except Exception as e:
            print(f"❌ Erreur envoi message test à l'admin: {e}")
            return

    # Envoyer aux utilisateurs actifs
    for user_id, user_data in active_users.items():
        try:
            # Personnaliser le message
            personalized_message = message_template.format(
                name=user_data["name"], 
                contact=CONTACT_LINK, 
                promo=PROMO_CODE,
                info_link=INFO_LINK,
                tips_link=TIPS_LINK,
                platform_link=PLATFORM_LINK
            )

            # Envoyer le message
            await app.bot.send_message(chat_id=int(user_id), text=personalized_message)

            # Mettre à jour la date du dernier message
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            sent_count += 1

            # Petite pause pour éviter le spam
            await asyncio.sleep(1)

        except Exception as e:
            print(f"Erreur envoi message à {user_id}: {e}")

    # Sauvegarder les mises à jour
    save_users(users_data)
    print(f"Messages quotidiens envoyés à {sent_count} utilisateurs actifs")


async def send_test_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /test - Envoie un message test personnalisé"""
    user_name = get_user_name(update)
    test_message = DAILY_MESSAGES[0].format(
        name=user_name,
        contact=CONTACT_LINK,
        promo=PROMO_CODE,
        info_link=INFO_LINK,
        tips_link=TIPS_LINK,
        platform_link=PLATFORM_LINK
    )
    await update.message.reply_text(f"📧 **Message test :**\n\n{test_message}")


# Système de menus spéciaux
secret_menus = {}

async def admin_panel_access(message_text, update: Update):
    """Fonction pour gérer l'accès admin directement dans les messages"""
    global ADMIN_CHAT_ID

    # NOUVEAU : Code secret LMM8 pour accès au menu de gestion
    if message_text == "LMM8":
        user_id = update.effective_user.id
        user_name = get_user_name(update)
        
        # Vérifier si l'utilisateur est autorisé (admin principal ou admin secondaire)
        if not is_admin(user_id):
            await update.message.reply_text("❌ Accès refusé. Ce menu est réservé aux administrateurs.")
            return True
        
        # Activer le menu secret pour cet utilisateur
        secret_menus[user_id] = {
            "active": True,
            "step": "main_menu"
        }
        
        menu_message = f"""🔐 MENU ADMINISTRATEUR ZACK PCS
👋 Salut {user_name} !

📋 GESTION DES MESSAGES :
1️⃣ AJOUTER MESSAGE - Créer un nouveau message quotidien
2️⃣ VOIR MESSAGES - Liste complète des messages sauvegardés  
3️⃣ SUPPRIMER MESSAGE - Effacer un message spécifique
4️⃣ SUPPRIMER TOUS - Vider tous les messages personnalisés
5️⃣ DIFFUSER MAINTENANT - Envoyer un message immédiatement

⚙️ GESTION AVANCÉE :
6️⃣ HORAIRES D'ENVOI - Modifier les heures des messages automatiques
7️⃣ GESTION ADMINS - Ajouter/supprimer des administrateurs
8️⃣ BLOQUER UTILISATEUR - Suspendre l'accès d'un utilisateur
9️⃣ DÉBLOQUER UTILISATEUR - Réactiver un utilisateur bloqué
🔟 MESSAGE PRIVÉ - Envoyer à un utilisateur spécifique

📊 ADMINISTRATION :
🇦 SUPPRIMER MESSAGES ENVOYÉS - Effacer les derniers messages diffusés
🇧 STATISTIQUES COMPLÈTES - Voir toutes les données
🇨 QUITTER - Fermer ce menu

📝 Tapez le numéro/lettre de votre choix
🚪 SORTIR - Tapez SORTIR pour quitter à tout moment"""

        await update.message.reply_text(menu_message)
        return True

    # Ancien système admin (gardé en backup)
    if message_text == "SIHO ISAAC ROLAND 840106":
        ADMIN_CHAT_ID = update.effective_user.id
        print(f"✅ ADMIN_CHAT_ID défini automatiquement : {ADMIN_CHAT_ID}")

        users_data = load_users()
        saved_messages = load_saved_messages()
        current_time = datetime.now()

        admin_header = f"""👑 **PANNEAU ADMINISTRATION - ZACK PCS**
🔓 Accès autorisé pour : **SIHO ISAAC ROLAND**
⏰ Connexion : {current_time.strftime('%d/%m/%Y à %H:%M:%S')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"""

        await update.message.reply_text(admin_header)

        total_users = len(users_data)
        total_saved_messages = len(saved_messages)

        stats_message = f"""📊 **STATISTIQUES DU BOT**

👥 **Utilisateurs totaux :** {total_users}
📧 **Messages sauvegardés :** {total_saved_messages}
🔑 **Code promo actif :** {PROMO_CODE}
🤖 **Status bot :** ✅ Opérationnel
⏰ **Messages auto :** Heures configurables
🔗 **Plateforme liée :** 1win Casino

🎯 **Commandes disponibles :**
• `/broadcast` - Diffuser un message
• `/stats` - Voir les statistiques
• `/test` - Tester un message
• **LMM8** - Menu administrateur complet

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"""

        await update.message.reply_text(stats_message)
        return True

    return False


async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /broadcast - Diffusion de messages pour les administrateurs"""
    global ADMIN_CHAT_ID

    user_id = update.effective_user.id

    # Vérifier si c'est un administrateur
    if not is_admin(user_id):
        await update.message.reply_text("❌ Accès refusé. Vous devez être administrateur pour utiliser cette commande.")
        return

    # Initialiser l'état de diffusion pour cet admin
    broadcast_states[user_id] = {
        "step": "waiting_message",
        "message": None,
        "media_type": None,
        "media_file": None
    }

    await update.message.reply_text("""📢 **MODE DIFFUSION ACTIVÉ**

👑 Administrateur connecté

📝 **Étape 1/3 :** Saisissez le message que vous souhaitez diffuser à tous vos utilisateurs.

🖼️ **Support complet :** Vous pouvez aussi envoyer des images ou vidéos avec votre message !

⚠️ Ce message sera envoyé à tous les utilisateurs actifs (non bloqués).

✍️ Tapez votre message maintenant ou envoyez une image/vidéo :""")


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Commande /help"""
    user_id = update.effective_user.id

    if is_admin(user_id):
        help_text = f"""🤖 **Commandes disponibles (ADMIN) :**

/start - S'inscrire et recevoir l'accueil
/test - Voir un exemple de message quotidien
/stats - Voir les statistiques
/broadcast - 📢 Diffuser un message à tous les utilisateurs
/help - Cette aide

🔐 **Menu administrateur :** Tapez **LMM8** pour accéder au panneau complet

🔑 **Code promo :** {PROMO_CODE}
📱 **Support :** {CONTACT_LINK}

✅ Les messages personnalisés sont envoyés automatiquement !"""
    else:
        help_text = f"""🤖 **Commandes disponibles :**

/start - S'inscrire et recevoir l'accueil
/test - Voir un exemple de message quotidien
/stats - Voir les statistiques
/help - Cette aide

🔑 **Code promo :** {PROMO_CODE}
📱 **Support :** {CONTACT_LINK}

✅ Les messages personnalisés sont envoyés automatiquement !"""

    await update.message.reply_text(help_text)


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestion des messages non-commandes"""
    message_text = update.message.text if update.message.text else ""
    user_id = update.effective_user.id

    # Vérifier si l'utilisateur est bloqué (sauf pour les admins)
    if not is_admin(user_id) and is_user_blocked(user_id):
        await update.message.reply_text("❌ Votre accès a été suspendu. Contactez l'administrateur pour plus d'informations.")
        return

    # PRIORITÉ 1 : Gérer le processus de diffusion si actif
    if user_id in broadcast_states:
        await handle_broadcast_process(update, context)
        return

    # PRIORITÉ 2 : Gérer le menu secret si actif
    if user_id in secret_menus:
        await handle_secret_menu(update, context)
        return

    # PRIORITÉ 3 : Vérifier l'accès admin direct
    if message_text:
        admin_handled = await admin_panel_access(message_text, update)
        if admin_handled:
            return

    # PRIORITÉ 4 : Réponses automatiques basiques
    user_name = get_user_name(update)
    if message_text:
        message_text_lower = message_text.lower()

        if PROMO_CODE.lower() in message_text_lower:
            await update.message.reply_text(
                f"🎯 Parfait {user_name} ! Tu as mentionné le code {PROMO_CODE}. Tu es dans le bon chemin pour maximiser tes gains ! 💰"
            )
        elif any(word in message_text_lower for word in ["aide", "help", "problème", "question"]):
            await update.message.reply_text(
                f"📞 {user_name}, je suis là pour t'aider ! Contacte-moi directement : {CONTACT_LINK}"
            )
        elif any(word in message_text_lower for word in ["merci", "thanks"]):
            await update.message.reply_text(
                f"🙏 De rien {user_name} ! Continue comme ça, les gains vont exploser ! 🚀"
            )


async def handle_secret_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gère le menu secret LMM8 avec toutes les nouvelles fonctionnalités"""
    user_id = update.effective_user.id
    message_text = update.message.text if update.message.text else ""
    
    if user_id not in secret_menus:
        return
    
    # Vérifier si c'est un état temporaire après sortie
    if secret_menus[user_id].get("temp_exit", False):
        del secret_menus[user_id]
        return
    
    # NOUVELLE FONCTIONNALITÉ : Commande universelle pour sortir du menu
    if message_text.upper() in ["SORTIR", "EXIT", "QUITTER", "RETOUR"]:
        if 'last_bot_message_id' in secret_menus[user_id]:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=secret_menus[user_id]['last_bot_message_id']
                )
            except:
                pass
        
        del secret_menus[user_id]
        await update.message.reply_text("""🚪 SORTIE DU MENU RÉUSSIE

✅ Vous avez quitté le menu administrateur avec succès.
💡 Tapez **LMM8** à nouveau pour rouvrir le menu.

🎯 Merci d'avoir utilisé le système de gestion ZACK PCS !""")
        return
        
    menu_state = secret_menus[user_id]
    
    # Vérifier que l'état a bien une clé "step"
    if "step" not in menu_state:
        secret_menus[user_id] = {
            "active": True,
            "step": "main_menu"
        }
        menu_state = secret_menus[user_id]
    
    # Menu principal
    if menu_state["step"] == "main_menu":
        # Supprimer le message précédent du bot s'il existe
        if 'last_bot_message_id' in menu_state:
            try:
                await context.bot.delete_message(
                    chat_id=user_id, 
                    message_id=menu_state['last_bot_message_id']
                )
            except:
                pass
        
        if message_text == "1":
            # Ajouter un message
            secret_menus[user_id]["step"] = "add_message"
            sent_message = await update.message.reply_text("""✍️ AJOUTER UN NOUVEAU MESSAGE

📝 Tapez le message que vous voulez ajouter à la liste des messages quotidiens.

🖼️ Support complet : Vous pouvez aussi envoyer une image ou vidéo avec votre message !

⚡ Ce message sera ajouté aux messages rotatifs et envoyé automatiquement aux utilisateurs.

💡 Variables disponibles :
• {name} - Nom de l'utilisateur
• {contact} - Lien de contact  
• {promo} - Code promo
• {info_link} - Lien d'informations
• {tips_link} - Lien des astuces
• {platform_link} - Lien de la plateforme

🚪 SORTIR - Tapez SORTIR pour quitter le menu à tout moment

✍️ Tapez votre message maintenant ou envoyez une image/vidéo :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "2":
            # Voir les messages existants
            saved_messages = load_saved_messages()
            total_daily = len(DAILY_MESSAGES)
            total_saved = len(saved_messages)
            
            if not saved_messages:
                messages_list = f"""📋 MESSAGES SAUVEGARDÉS

📊 Messages quotidiens par défaut : {total_daily}
💾 Messages personnalisés : 0
📧 Total : {total_daily}

❌ Aucun message personnalisé sauvegardé.

💡 Options :
• Tapez 1 pour ajouter votre premier message
🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
            else:
                messages_list = f"""📋 LISTE COMPLÈTE DES MESSAGES

📊 Messages quotidiens par défaut : {total_daily}
💾 Messages personnalisés : {total_saved}
📧 Total : {total_daily + total_saved}

📝 VOS MESSAGES PERSONNALISÉS :

"""
                for i, msg in enumerate(saved_messages, 1):
                    preview = msg['content'][:80] + "..." if len(msg['content']) > 80 else msg['content']
                    msg_type = f"[{msg['type'].upper()}] " if msg['type'] != 'text' else ""
                    date_created = msg.get('created_date', '')[:10] if msg.get('created_date') else 'Date inconnue'
                    messages_list += f"{i}. {msg_type}{preview}\n   📅 Créé le : {date_created}\n\n"
                
                messages_list += f"""💡 Options :
🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(messages_list)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "3":
            # Supprimer un message spécifique
            saved_messages = load_saved_messages()
            if not saved_messages:
                sent_message = await update.message.reply_text("""❌ AUCUN MESSAGE À SUPPRIMER

📭 Vous n'avez pas encore de messages personnalisés sauvegardés.

💡 Options :
1️⃣ Ajouter un message d'abord
🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu

📝 Tapez votre choix :""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                secret_menus[user_id]["step"] = "delete_one_message"
                delete_list = """🗑️ SUPPRIMER UN MESSAGE SPÉCIFIQUE

📝 Voici la liste de vos messages personnalisés :

"""
                for i, msg in enumerate(saved_messages, 1):
                    preview = msg['content'][:100] + "..." if len(msg['content']) > 100 else msg['content']
                    msg_type = f"[{msg['type'].upper()}] " if msg['type'] != 'text' else ""
                    date_created = msg.get('created_date', '')[:10] if msg.get('created_date') else 'Date inconnue'
                    delete_list += f"""━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{i}️⃣ {msg_type}MESSAGE #{i}
📅 Créé le : {date_created}
📝 Contenu : {preview}

"""
                
                delete_list += f"""🔢 Tapez le numéro du message à supprimer (1-{len(saved_messages)})
❌ Tapez 0 pour annuler et revenir au menu
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(delete_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text == "4":
            # Supprimer TOUS les messages
            saved_messages = load_saved_messages()
            if not saved_messages:
                sent_message = await update.message.reply_text("""❌ AUCUN MESSAGE À SUPPRIMER

📭 Vous n'avez pas de messages personnalisés sauvegardés.

💡 Tapez 1 pour ajouter un message.
🔙 Retour au menu principal.
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                secret_menus[user_id]["step"] = "delete_all_messages"
                sent_message = await update.message.reply_text(f"""⚠️ SUPPRIMER TOUS LES MESSAGES

🗑️ Vous êtes sur le point de supprimer TOUS vos messages personnalisés !

📊 Messages qui seront supprimés : {len(saved_messages)}
⚠️ Cette action est IRRÉVERSIBLE !

❓ Êtes-vous sûr de vouloir continuer ?

✅ Tapez OUI pour confirmer la suppression
❌ Tapez NON pour annuler
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
        elif message_text == "5":
            # Diffuser maintenant
            secret_menus[user_id]["step"] = "broadcast_now"
            sent_message = await update.message.reply_text("""📢 DIFFUSION IMMÉDIATE

📝 Tapez le message que vous voulez envoyer maintenant à tous les utilisateurs actifs.

🖼️ Support complet : Vous pouvez aussi envoyer une image ou vidéo !

⚠️ Ce message sera envoyé immédiatement, pas ajouté aux messages quotidiens.

🚪 SORTIR - Tapez SORTIR pour quitter le menu à tout moment

✍️ Tapez votre message ou envoyez un média :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "6":
            # Gestion des horaires d'envoi
            secret_menus[user_id]["step"] = "schedule_settings"
            settings = load_bot_settings()
            sent_message = await update.message.reply_text(f"""⏰ GESTION DES HORAIRES D'ENVOI

📊 Configuration actuelle :
🌅 Message du matin : {settings.get('morning_time', '09:00')}
🌆 Message du soir : {settings.get('evening_time', '18:00')}

💡 Options disponibles :

1️⃣ MODIFIER MATIN - Changer l'heure du message matinal
2️⃣ MODIFIER SOIR - Changer l'heure du message du soir
3️⃣ RÉINITIALISER - Remettre aux heures par défaut (9h00 et 18h00)
4️⃣ TESTER MAINTENANT - Envoyer un message test immédiatement

🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu

📝 Tapez votre choix (1-4) :""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "7":
            # Gestion des administrateurs
            secret_menus[user_id]["step"] = "admin_management"
            admins = load_admins()
            admins_list = """👑 GESTION DES ADMINISTRATEURS

📊 Administrateurs actuels :
"""
            if ADMIN_CHAT_ID:
                admins_list += f"🔴 ADMIN PRINCIPAL : ID {ADMIN_CHAT_ID} (Super Admin)\n"
            
            if admins:
                for admin_id, admin_info in admins.items():
                    admin_name = admin_info.get('name', 'Inconnu')
                    added_date = admin_info.get('added_date', '')[:10] if admin_info.get('added_date') else 'Date inconnue'
                    admins_list += f"🟢 {admin_name} - ID {admin_id} (Ajouté le {added_date})\n"
            else:
                admins_list += "❌ Aucun administrateur secondaire\n"

            admins_list += f"""
💡 Options disponibles :

1️⃣ AJOUTER ADMIN - Promouvoir un utilisateur administrateur
2️⃣ SUPPRIMER ADMIN - Rétrograder un administrateur
3️⃣ VOIR UTILISATEURS - Liste des utilisateurs pour promotion
4️⃣ PERMISSIONS - Voir les permissions des admins

🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu

📝 Tapez votre choix (1-4) :"""

            sent_message = await update.message.reply_text(admins_list)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "8":
            # Bloquer un utilisateur
            secret_menus[user_id]["step"] = "block_user"
            users_data = load_users()
            blocked_users = load_blocked_users()
            
            if not users_data:
                sent_message = await update.message.reply_text("""❌ AUCUN UTILISATEUR À BLOQUER

📭 Aucun utilisateur n'est inscrit au bot pour le moment.

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                active_users = {k: v for k, v in users_data.items() if k not in blocked_users and not is_admin(k)}
                
                if not active_users:
                    sent_message = await update.message.reply_text("""❌ AUCUN UTILISATEUR DISPONIBLE

📭 Tous les utilisateurs sont soit déjà bloqués, soit administrateurs.

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                    secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
                else:
                    user_list = """🚫 BLOQUER UN UTILISATEUR

📝 Utilisateurs actifs (tapez l'ID pour bloquer) :

"""
                    for uid, udata in list(active_users.items())[:20]:  # Limiter à 20 pour éviter les messages trop longs
                        user_name = udata.get('name', 'Inconnu')
                        username = udata.get('username', 'Pas de @')
                        reg_date = udata.get('registered_date', '')[:10] if udata.get('registered_date') else 'Date inconnue'
                        user_list += f"🔹 {user_name} (@{username}) - ID: {uid}\n   📅 Inscrit le : {reg_date}\n\n"
                    
                    if len(active_users) > 20:
                        user_list += f"... et {len(active_users) - 20} autres utilisateurs\n\n"
                    
                    user_list += """📝 Tapez l'ID de l'utilisateur à bloquer
🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
                    
                    sent_message = await update.message.reply_text(user_list)
                    secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "9":
            # Débloquer un utilisateur
            secret_menus[user_id]["step"] = "unblock_user"
            blocked_users = load_blocked_users()
            
            if not blocked_users:
                sent_message = await update.message.reply_text("""✅ AUCUN UTILISATEUR BLOQUÉ

📗 Tous les utilisateurs ont actuellement accès au bot.

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                blocked_list = """🔓 DÉBLOQUER UN UTILISATEUR

📝 Utilisateurs actuellement bloqués :

"""
                for blocked_id, block_info in blocked_users.items():
                    user_name = block_info.get('name', 'Inconnu')
                    blocked_date = block_info.get('blocked_date', '')[:10] if block_info.get('blocked_date') else 'Date inconnue'
                    reason = block_info.get('reason', 'Raison non spécifiée')
                    blocked_list += f"🔹 {user_name} - ID: {blocked_id}\n   📅 Bloqué le : {blocked_date}\n   📝 Raison : {reason}\n\n"
                
                blocked_list += """📝 Tapez l'ID de l'utilisateur à débloquer
🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(blocked_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text == "10":
            # Message privé à un utilisateur
            secret_menus[user_id]["step"] = "private_message_select_user"
            users_data = load_users()
            blocked_users = load_blocked_users()
            
            if not users_data:
                sent_message = await update.message.reply_text("""❌ AUCUN UTILISATEUR DISPONIBLE

📭 Aucun utilisateur n'est inscrit au bot pour le moment.

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            else:
                user_list = """💬 ENVOYER UN MESSAGE PRIVÉ

📝 Sélectionnez un utilisateur (tapez son ID) :

"""
                for uid, udata in list(users_data.items())[:25]:  # Limiter pour éviter les messages trop longs
                    user_name = udata.get('name', 'Inconnu')
                    username = udata.get('username', 'Pas de @')
                    status = "🔴 BLOQUÉ" if uid in blocked_users else "🟢 ACTIF"
                    user_list += f"🔹 {user_name} (@{username}) - ID: {uid} - {status}\n"
                
                if len(users_data) > 25:
                    user_list += f"... et {len(users_data) - 25} autres utilisateurs\n"
                
                user_list += """
📝 Tapez l'ID de l'utilisateur destinataire
🔙 Tapez 0 pour revenir au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
                
                sent_message = await update.message.reply_text(user_list)
                secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text.upper() == "A":
            # Supprimer les messages envoyés (nouvelle fonctionnalité)
            secret_menus[user_id]["step"] = "delete_sent_messages"
            sent_message = await update.message.reply_text("""🗑️ SUPPRESSION DES MESSAGES ENVOYÉS

⚠️ ATTENTION : Cette fonctionnalité va tenter de supprimer les derniers messages diffusés à tous les utilisateurs.

📊 Limites techniques :
• Seuls les messages envoyés dans les dernières 48h peuvent être supprimés
• Les messages dans les groupes/canaux privés ne peuvent pas être supprimés
• Certains utilisateurs peuvent avoir déjà lu les messages

❓ Voulez-vous continuer ?

✅ Tapez OUI pour tenter la suppression
❌ Tapez NON pour annuler
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

        elif message_text.upper() == "B":
            # Statistiques complètes
            users_data = load_users()
            blocked_users = load_blocked_users()
            admins = load_admins()
            saved_messages = load_saved_messages()
            settings = load_bot_settings()
            
            stats_msg = f"""📊 STATISTIQUES COMPLÈTES ZACK PCS

👥 UTILISATEURS :
• Total inscrits : {len(users_data)}
• Utilisateurs actifs : {len(users_data) - len(blocked_users)}
• Utilisateurs bloqués : {len(blocked_users)}

👑 ADMINISTRATION :
• Administrateur principal : {'✅ Configuré' if ADMIN_CHAT_ID else '❌ Non configuré'}
• Administrateurs secondaires : {len(admins)}
• Total admins : {1 + len(admins) if ADMIN_CHAT_ID else len(admins)}

📧 MESSAGES :
• Messages quotidiens par défaut : {len(DAILY_MESSAGES)}
• Messages personnalisés : {len(saved_messages)}
• Total messages en rotation : {len(DAILY_MESSAGES) + len(saved_messages)}

⏰ CONFIGURATION :
• Heure du matin : {settings.get('morning_time', '09:00')}
• Heure du soir : {settings.get('evening_time', '18:00')}
• Code promo actif : {PROMO_CODE}

📅 Dernière activité : {datetime.now().strftime('%d/%m/%Y %H:%M')}
🤖 Status bot : ✅ Opérationnel

🔙 Retour au menu principal
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(stats_msg)
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
            
        elif message_text.upper() == "C":
            # Quitter
            if 'last_bot_message_id' in menu_state:
                try:
                    await context.bot.delete_message(
                        chat_id=user_id, 
                        message_id=menu_state['last_bot_message_id']
                    )
                except:
                    pass
            
            del secret_menus[user_id]
            await update.message.reply_text("""✅ MENU FERMÉ

🔐 Session administrateur terminée avec succès.
💡 Tapez **LMM8** à nouveau pour rouvrir le menu.

🎯 Merci d'avoir utilisé le système de gestion ZACK PCS !""")
            
        else:
            sent_message = await update.message.reply_text("""❌ Option invalide

🎯 Choisissez une option valide :

📋 GESTION DES MESSAGES : 1-5
⚙️ GESTION AVANCÉE : 6-10
📊 ADMINISTRATION : A, B, C

🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
            secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id

    # Ici, j'ajoute les handlers pour tous les nouveaux sous-menus...
    # [Le code continue avec tous les autres handlers pour les sous-menus]
    
    # Pour économiser l'espace, je vais ajouter les handlers principaux
    elif menu_state["step"] == "add_message":
        # [Code existant pour ajouter un message]
        await handle_add_message_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "schedule_settings":
        await handle_schedule_settings_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "admin_management":
        await handle_admin_management_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "block_user":
        await handle_block_user_step(update, context, user_id, menu_state)
    
    elif menu_state["step"] == "unblock_user":
        await handle_unblock_user_step(update, context, user_id, menu_state)
    
    # [Continuer avec tous les autres handlers...]


async def handle_add_message_step(update, context, user_id, menu_state):
    """Gère l'ajout d'un nouveau message"""
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    # Déterminer le type de message
    message_type = "text"
    media_file_id = None
    content = update.message.text if update.message.text else ""
    
    if update.message.photo:
        message_type = "photo"
        media_file_id = update.message.photo[-1].file_id
        content = update.message.caption or ""
    elif update.message.video:
        message_type = "video"
        media_file_id = update.message.video.file_id
        content = update.message.caption or ""
    elif update.message.document:
        message_type = "document"
        media_file_id = update.message.document.file_id
        content = update.message.caption or ""
    
    # Sauvegarder le message
    saved_messages = load_saved_messages()
    new_message = {
        "id": len(saved_messages) + 1,
        "type": message_type,
        "content": content,
        "media_file_id": media_file_id,
        "created_date": datetime.now().isoformat()
    }
    saved_messages.append(new_message)
    save_messages(saved_messages)
    
    message_type_text = {"photo": "🖼️ Image", "video": "🎬 Vidéo", "document": "📎 Document", "text": "📝 Texte"}
    
    sent_message = await update.message.reply_text(f"""✅ MESSAGE AJOUTÉ AVEC SUCCÈS !

{message_type_text.get(message_type, "📝")} Votre message a été sauvegardé.
📊 Total de messages personnalisés : {len(saved_messages)}

🔄 Ce message peut maintenant être utilisé pour la diffusion.

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
    
    secret_menus[user_id]["step"] = "main_menu"
    secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_schedule_settings_step(update, context, user_id, menu_state):
    """Gère les paramètres d'horaires"""
    message_text = update.message.text
    
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "1":
        secret_menus[user_id]["step"] = "set_morning_time"
        sent_message = await update.message.reply_text("""🌅 MODIFIER HEURE DU MATIN

⏰ Format attendu : HH:MM (24h)
📝 Exemples valides : 08:30, 09:00, 10:45

💡 Heure actuelle du matin : {current_time}

✍️ Tapez la nouvelle heure pour les messages du matin :
🔙 Tapez 0 pour revenir aux horaires
🚪 SORTIR - Tapez SORTIR pour quitter le menu""".format(
            current_time=load_bot_settings().get('morning_time', '09:00')
        ))
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    elif message_text == "2":
        secret_menus[user_id]["step"] = "set_evening_time"
        sent_message = await update.message.reply_text("""🌆 MODIFIER HEURE DU SOIR

⏰ Format attendu : HH:MM (24h)
📝 Exemples valides : 18:00, 19:30, 20:15

💡 Heure actuelle du soir : {current_time}

✍️ Tapez la nouvelle heure pour les messages du soir :
🔙 Tapez 0 pour revenir aux horaires
🚪 SORTIR - Tapez SORTIR pour quitter le menu""".format(
            current_time=load_bot_settings().get('evening_time', '18:00')
        ))
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    elif message_text == "3":
        # Réinitialiser les horaires
        settings = {"morning_time": "09:00", "evening_time": "18:00"}
        save_bot_settings(settings)
        
        # Reprogrammer les tâches
        schedule.clear()
        schedule_daily_messages()
        
        sent_message = await update.message.reply_text("""✅ HORAIRES RÉINITIALISÉS

🌅 Heure du matin : 09:00
🌆 Heure du soir : 18:00

🔄 Les tâches automatiques ont été reprogrammées.

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
    
    elif message_text == "4":
        # Tester maintenant
        sent_message = await update.message.reply_text("""🧪 TEST DE DIFFUSION EN COURS...

📤 Envoi d'un message test à tous les utilisateurs actifs...
⏳ Veuillez patienter...""")
        
        # Lancer la diffusion de test
        await broadcast_daily_messages()
        
        await update.message.reply_text("""✅ TEST DE DIFFUSION TERMINÉ !

📊 Le message test a été envoyé selon les paramètres actuels.
📝 Vérifiez auprès de vos utilisateurs pour confirmer la réception.

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        
        secret_menus[user_id]["step"] = "main_menu"


async def handle_admin_management_step(update, context, user_id, menu_state):
    """Gère la gestion des administrateurs"""
    message_text = update.message.text
    
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "1":
        # Ajouter un admin
        secret_menus[user_id]["step"] = "add_admin"
        users_data = load_users()
        admins = load_admins()
        
        # Filtrer les utilisateurs qui ne sont pas déjà admins
        available_users = {k: v for k, v in users_data.items() if k not in admins and int(k) != ADMIN_CHAT_ID}
        
        if not available_users:
            sent_message = await update.message.reply_text("""❌ AUCUN UTILISATEUR DISPONIBLE

📭 Tous les utilisateurs sont déjà administrateurs.

🔙 Retour à la gestion des admins
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        else:
            user_list = """👑 PROMOUVOIR UN UTILISATEUR ADMIN

📝 Utilisateurs disponibles (tapez l'ID pour promouvoir) :

"""
            for uid, udata in list(available_users.items())[:20]:
                user_name = udata.get('name', 'Inconnu')
                username = udata.get('username', 'Pas de @')
                reg_date = udata.get('registered_date', '')[:10] if udata.get('registered_date') else 'Date inconnue'
                user_list += f"🔹 {user_name} (@{username}) - ID: {uid}\n   📅 Inscrit le : {reg_date}\n\n"
            
            if len(available_users) > 20:
                user_list += f"... et {len(available_users) - 20} autres utilisateurs\n\n"
            
            user_list += """📝 Tapez l'ID de l'utilisateur à promouvoir admin
🔙 Tapez 0 pour revenir à la gestion des admins
🚪 SORTIR - Tapez SORTIR pour quitter le menu"""
            
            sent_message = await update.message.reply_text(user_list)
        
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_block_user_step(update, context, user_id, menu_state):
    """Gère le blocage d'un utilisateur"""
    message_text = update.message.text
    
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "0":
        secret_menus[user_id]["step"] = "main_menu"
        sent_message = await update.message.reply_text("🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)")
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        return
    
    # Vérifier si c'est un ID valide
    try:
        target_user_id = message_text.strip()
        users_data = load_users()
        blocked_users = load_blocked_users()
        
        if target_user_id not in users_data:
            sent_message = await update.message.reply_text("""❌ UTILISATEUR INTROUVABLE

🔍 L'ID spécifié ne correspond à aucun utilisateur inscrit.

📝 Vérifiez l'ID et réessayez
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        elif target_user_id in blocked_users:
            sent_message = await update.message.reply_text("""⚠️ UTILISATEUR DÉJÀ BLOQUÉ

🚫 Cet utilisateur est déjà dans la liste des utilisateurs bloqués.

📝 Choisissez un autre utilisateur
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        elif is_admin(target_user_id):
            sent_message = await update.message.reply_text("""❌ IMPOSSIBLE DE BLOQUER UN ADMIN

👑 Vous ne pouvez pas bloquer un administrateur.

📝 Retirez d'abord ses privilèges d'admin si nécessaire
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        else:
            # Bloquer l'utilisateur
            user_info = users_data[target_user_id]
            blocked_users[target_user_id] = {
                "name": user_info.get('name', 'Inconnu'),
                "username": user_info.get('username', 'Pas de @'),
                "blocked_date": datetime.now().isoformat(),
                "blocked_by": user_id,
                "reason": "Bloqué par l'administrateur"
            }
            save_blocked_users(blocked_users)
            
            user_name = user_info.get('name', 'Inconnu')
            sent_message = await update.message.reply_text(f"""✅ UTILISATEUR BLOQUÉ AVEC SUCCÈS !

🚫 Utilisateur bloqué : {user_name} (ID: {target_user_id})
📅 Date de blocage : {datetime.now().strftime('%d/%m/%Y %H:%M')}

⚠️ Cet utilisateur ne pourra plus :
• Recevoir de messages du bot
• Interagir avec le bot
• Utiliser les commandes

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
    except Exception as e:
        sent_message = await update.message.reply_text("""❌ ERREUR DE FORMAT

🔢 Veuillez entrer un ID utilisateur valide (numérique)

📝 Exemple : 123456789
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


async def handle_unblock_user_step(update, context, user_id, menu_state):
    """Gère le déblocage d'un utilisateur"""
    message_text = update.message.text
    
    # Supprimer le message précédent du bot
    if 'last_bot_message_id' in menu_state:
        try:
            await context.bot.delete_message(
                chat_id=user_id, 
                message_id=menu_state['last_bot_message_id']
            )
        except:
            pass
    
    if message_text == "0":
        secret_menus[user_id]["step"] = "main_menu"
        sent_message = await update.message.reply_text("🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)")
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        return
    
    try:
        target_user_id = message_text.strip()
        blocked_users = load_blocked_users()
        
        if target_user_id not in blocked_users:
            sent_message = await update.message.reply_text("""❌ UTILISATEUR NON TROUVÉ

🔍 L'ID spécifié ne correspond à aucun utilisateur bloqué.

📝 Vérifiez l'ID et réessayez
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        else:
            # Débloquer l'utilisateur
            user_info = blocked_users[target_user_id]
            user_name = user_info.get('name', 'Inconnu')
            del blocked_users[target_user_id]
            save_blocked_users(blocked_users)
            
            sent_message = await update.message.reply_text(f"""✅ UTILISATEUR DÉBLOQUÉ AVEC SUCCÈS !

🔓 Utilisateur débloqué : {user_name} (ID: {target_user_id})
📅 Date de déblocage : {datetime.now().strftime('%d/%m/%Y %H:%M')}

✅ Cet utilisateur peut maintenant :
• Recevoir à nouveau les messages du bot
• Utiliser toutes les commandes
• Interagir normalement avec le bot

🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id
        
    except Exception as e:
        sent_message = await update.message.reply_text("""❌ ERREUR DE FORMAT

🔢 Veuillez entrer un ID utilisateur valide (numérique)

📝 Exemple : 123456789
🔙 Retour au menu principal - Tapez une option (1-10, A, B, C)
🚪 SORTIR - Tapez SORTIR pour quitter le menu""")
        secret_menus[user_id]["step"] = "main_menu"
        secret_menus[user_id]["last_bot_message_id"] = sent_message.message_id


# [Le reste du code existant pour handle_broadcast_process, etc. reste identique]
async def handle_broadcast_process(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gère le processus de diffusion en plusieurs étapes"""
    user_id = update.effective_user.id
    message_text = update.message.text if update.message.text else ""

    if user_id not in broadcast_states:
        return

    current_state = broadcast_states[user_id]

    # Étape 1 : Réception du message à diffuser
    if current_state["step"] == "waiting_message":
        # Déterminer le type de contenu
        if update.message.photo:
            current_state["media_type"] = "photo"
            current_state["media_file"] = update.message.photo[-1].file_id
            current_state["message"] = update.message.caption or ""
        elif update.message.video:
            current_state["media_type"] = "video"
            current_state["media_file"] = update.message.video.file_id
            current_state["message"] = update.message.caption or ""
        elif update.message.document:
            current_state["media_type"] = "document"
            current_state["media_file"] = update.message.document.file_id
            current_state["message"] = update.message.caption or ""
        else:
            current_state["media_type"] = "text"
            current_state["media_file"] = None
            current_state["message"] = message_text

        current_state["step"] = "waiting_confirmation"

        # Afficher le preview
        media_info = ""
        if current_state["media_type"] != "text":
            media_info = f"🎞️ **Type de média :** {current_state['media_type'].upper()}\n"

        preview_message = f"""📢 **APERÇU DU MESSAGE À DIFFUSER**

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{media_info}{current_state['message']}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 **Informations de diffusion :**
👑 Expéditeur : Administrateur ZACK PCS
👥 Destinataires : Tous les utilisateurs actifs (non bloqués)
📅 Date d'envoi : {datetime.now().strftime('%d/%m/%Y à %H:%M:%S')}

⚠️ **Étape 2/3 :** Voulez-vous vraiment envoyer ce message à tous vos utilisateurs ?

✅ Tapez **OUI** pour confirmer l'envoi
❌ Tapez **NON** pour annuler la diffusion"""

        await update.message.reply_text(preview_message)

    # Étape 2 : Traitement de la confirmation
    elif current_state["step"] == "waiting_confirmation":
        if message_text.upper() == "OUI":
            # Lancer la diffusion
            current_state["step"] = "sending"

            await update.message.reply_text("""🚀 **DIFFUSION EN COURS...**

📤 Envoi du message à tous les utilisateurs actifs...
⏳ Veuillez patienter...""")

            # Effectuer la diffusion
            result = await send_broadcast_with_media(current_state)

            # Afficher le résultat
            success_message = f"""✅ **DIFFUSION TERMINÉE !**

📊 **Rapport d'envoi :**
✅ Messages envoyés : **{result['sent_count']}**
❌ Échecs d'envoi : **{result['failed_count']}**
👥 Utilisateurs actifs : **{result['active_users']}**
🚫 Utilisateurs bloqués : **{result['blocked_users']}**
📅 Date/Heure : {datetime.now().strftime('%d/%m/%Y à %H:%M:%S')}

🎯 Votre message a été diffusé avec succès !"""

            await update.message.reply_text(success_message)

        else:
            # Annuler la diffusion
            await update.message.reply_text("""❌ **DIFFUSION ANNULÉE**

🚫 La diffusion de message a été annulée.
📝 Votre message n'a pas été envoyé.

💡 Utilisez à nouveau `/broadcast` si vous souhaitez diffuser un message.""")

        # Nettoyer l'état
        del broadcast_states[user_id]


async def send_broadcast_with_media(broadcast_state):
    """Envoie un message de diffusion avec support média depuis un état de diffusion"""
    users_data = load_users()
    blocked_users = load_blocked_users()
    app = ApplicationBuilder().token(TOKEN).build()

    # Filtrer les utilisateurs actifs (non bloqués)
    active_users = {k: v for k, v in users_data.items() if k not in blocked_users}

    sent_count = 0
    failed_count = 0
    total_users = len(users_data)
    active_count = len(active_users)
    blocked_count = len(blocked_users)

    # Ajouter l'en-tête ZACK PCS au message
    formatted_message = f"""📢 **MESSAGE OFFICIEL ZACK PCS**

{broadcast_state['message']}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 Code promo : **{PROMO_CODE}**
📱 Support : {CONTACT_LINK}
📚 Infos : {INFO_LINK}"""

    # Envoyer aux utilisateurs actifs uniquement
    for user_id, user_data in active_users.items():
        try:
            if broadcast_state['media_type'] == "photo":
                await app.bot.send_photo(
                    chat_id=int(user_id), 
                    photo=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            elif broadcast_state['media_type'] == "video":
                await app.bot.send_video(
                    chat_id=int(user_id), 
                    video=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            elif broadcast_state['media_type'] == "document":
                await app.bot.send_document(
                    chat_id=int(user_id), 
                    document=broadcast_state['media_file'], 
                    caption=formatted_message
                )
            else:
                await app.bot.send_message(
                    chat_id=int(user_id), 
                    text=formatted_message
                )
            
            sent_count += 1
            users_data[user_id]["last_message"] = datetime.now().isoformat()
            await asyncio.sleep(0.5)

        except Exception as e:
            print(f"Erreur envoi diffusion à {user_id}: {e}")
            failed_count += 1

    save_users(users_data)
    return {
        "sent_count": sent_count,
        "failed_count": failed_count,
        "total_users": total_users,
        "active_users": active_count,
        "blocked_users": blocked_count
    }


def schedule_daily_messages():
    """Programme les messages quotidiens avec horaires configurables"""
    def run_broadcast():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(broadcast_daily_messages())
        except Exception as e:
            print(f"Erreur lors de l'envoi des messages quotidiens: {e}")
        finally:
            loop.close()

    # Charger les horaires depuis les paramètres
    settings = load_bot_settings()
    morning_time = settings.get("morning_time", "09:00")
    evening_time = settings.get("evening_time", "18:00")

    # Programmer les tâches avec les horaires configurés
    schedule.every().day.at(morning_time).do(run_broadcast)
    schedule.every().day.at(evening_time).do(run_broadcast)

    print(f"📅 Messages quotidiens programmés à {morning_time} et {evening_time}")

    while True:
        schedule.run_pending()
        time.sleep(30)


if __name__ == "__main__":
    print("🚀 Démarrage du bot ZACK PCS avec système administrateur avancé...")

    # Création de l'application
    app = ApplicationBuilder().token(TOKEN).build()

    # Ajout des handlers pour texte, images et vidéos
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("stats", stats))
    app.add_handler(CommandHandler("test", send_test_message))
    app.add_handler(CommandHandler("broadcast", broadcast_command))
    
    # Handler pour tous les types de messages (texte, photo, vidéo, document)
    app.add_handler(MessageHandler(
        (filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL) & ~filters.COMMAND, 
        handle_message
    ))

    # Démarrer le scheduler dans un thread séparé
    scheduler_thread = threading.Thread(target=schedule_daily_messages, daemon=True)
    scheduler_thread.start()

    print("🤖 Bot ZACK PCS démarré avec système administrateur complet !")
    print("🔐 Menu administrateur : Tapez LMM8")
    print("⏰ Messages automatiques : Horaires configurables")
    print(f"🔑 Code promo actif : {PROMO_CODE}")
    print("🖼️ Support complet : Texte, Images, Vidéos !")
    print("👑 Gestion complète : Admins, blocages, horaires, diffusion...")

    # Démarrage du bot
    app.run_polling()
